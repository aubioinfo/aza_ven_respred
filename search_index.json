[["index.html", "Precision Prediction of Venetoclax-Azacitidine Treatment Efficacy in Acute Myeloid Leukemia via Integrative Drug Screening and Machine Learning Chapter 1 Background", " Precision Prediction of Venetoclax-Azacitidine Treatment Efficacy in Acute Myeloid Leukemia via Integrative Drug Screening and Machine Learning Peng Jin, Qiqi Jin, Kankan Wang 2025-07-20 Chapter 1 Background Acute myeloid leukemia (AML) is an aggressive hematologic malignancy characterized by significant biological heterogeneity and poor clinical outcomes, particularly among elderly patients who are unfit for intensive chemotherapy 1,2. Venetoclax, a selective BCL-2 inhibitor combined with hypomethylating agents, has recently emerged as a standard frontline therapy for newly diagnosed AML patients ineligible for intensive chemotherapy 1,3. However, despite these advancements, a substantial proportion of patients fail to achieve durable clinical benefit, primarily due to AML’s intrinsic biological complexity and clinical heterogeneity. The currently established risk stratification schemas, such as the European LeukemiaNet (ELN2022) classification 4, are primarily derived from studies involving younger AML patients receiving intensive chemotherapy, significantly limiting their predictive accuracy for older or unfit patients undergoing venetoclax-based therapies. To address this gap, several prognostic frameworks have been proposed specifically for venetoclax-based regimens. For example, Döhner et al. 5 introduced a concise four-gene model incorporating TP53, FLT3-ITD, NRAS, and KRAS mutations, while DiNardo et al. 6 and Gangat et al. 7 developed additional cohort-specific molecular models involving mutations in NPM1, IDH2, DDX41 and RUNX1. Nonetheless, these mutation-based models exhibit notable limitations, such as inadequate representation of the broad genomic and transcriptomic diversity within AML, insufficient integration of multi-layered biological information, and inconsistent predictive performance across diverse real-world patient populations 8. Consequently, there remains an unmet clinical need for novel approaches capable of comprehensively capturing the biological complexity associated with therapeutic responsiveness. Integrating multi-omics data with advanced machine learning (ML) methodologies provides a promising avenue to overcome these limitations. ML approaches can systematically leverage complex omics datasets, effectively capturing gene-gene interactions and dynamic molecular pathways that more accurately reflect the cellular and molecular mechanisms underpinning drug responsiveness 9,10. Recent studies have highlighted that drug sensitivity profiling strongly correlates with clinical outcomes in patients treated with venetoclax-azacitidine 11,12, thus reinforcing the biological relevance of incorporating drug response data into predictive modeling. However, the upstream molecular modulators influencing drug sensitivity remain incompletely characterized. Therefore, in the present study, we aimed to systematically dissect the cellular and molecular determinants underlying responsiveness to venetoclax-azacitidine therapy by integrating comprehensive drug sensitivity profiling with transcriptomic and genomic datasets. Using matched RNA-seq and drug sensitivity data, we identified key transcriptomic features associated with therapeutic sensitivity. Through rigorous evaluation of multiple ML classifiers using extensive cross-validation, we developed an optimized random forest model consisting of eight essential transcriptomic features (RF8). The RF8 model exhibited superior predictive performance across both internal and external validation cohorts, surpassing existing mutation-based risk stratification frameworks in accuracy. Additionally, RF8 provided consistent, monotonic correlations with clinical outcomes, including response probability, event-free survival (EFS), and overall survival (OS). Collectively, our findings underscore the clinical applicability and enhanced predictive capability of integrative, multi-omics-informed ML models relative to existing mutation-centric approaches for predicting treatment response in AML patients receiving venetoclax-azacitidine therapy. "],["figure-1.html", "Chapter 2 Figure 1", " Chapter 2 Figure 1 Ex vivo drug sensitivity and transcriptomic profiling reveal distinct molecular features associated with venetoclax-azacitidine response knitr::opts_chunk$set( fig.path = &quot;figures/&quot;, echo = TRUE, warning = FALSE, message = FALSE ) "],["process-the-data-from-functional_precision_medicine_tumor_board_aml.html", "2.1 Process the data from Functional_Precision_Medicine_Tumor_Board_AML", " 2.1 Process the data from Functional_Precision_Medicine_Tumor_Board_AML ## Normalize raw counts into TPM # count &lt;- read.csv(&quot;../02.data/File_8_RNA_seq_Raw_Reads_163S_4Healthy.csv&quot;, header = T) # colnames(count)[1] &lt;- &quot;id2&quot; # length &lt;- read.csv(&quot;../02.data/gencode.v22_geneLength.csv&quot;, header = T) # count &lt;- merge(length, count, by = &quot;id2&quot;) # row.names(count) &lt;- count$id2 # count &lt;- count[, -c(1:5)] # # row.names(length) &lt;- length$id2 # length &lt;- length[row.names(count), ] # Length &lt;- as.vector(length$length) # TPM &lt;- t(t(count / t(Length)) * 1e6 / colSums(count / t(Length))) # tpm &lt;- cbind(length, TPM) # tpm &lt;- tpm[, -c(1:3)] # #write.csv(tpm, &quot;../02.data/File_8_RNA_seq_TPM_163S_4Healthy.csv&quot;) # # ## load the drug profiling data # library(readxl) # drug &lt;- read.csv(&quot;../02.data/File_3_Drug_response_sDSS_164S_17Healthy.csv&quot;, header =TRUE, check.names = FALSE) # ## overlapped samples profiled by RNA-seq and Drug profiling # samples &lt;- intersect(colnames(tpm), colnames(drug)) # tpm &lt;- tpm[, c(&quot;Symbol&quot;, &quot;Type&quot;, samples)] # drug &lt;- drug[, c(&quot;Drug_name&quot;, samples)] "],["functional_precision_medicine_tumor_board_aml.html", "2.2 Functional_Precision_Medicine_Tumor_Board_AML", " 2.2 Functional_Precision_Medicine_Tumor_Board_AML library(pheatmap) func_drug &lt;- read.csv(&quot;../02.data/File_3_Drug_response_sDSS_164S_17Healthy.csv&quot;, header = T) func_drug &lt;- subset(func_drug, Drug_name %in% c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;)) sampleid &lt;- read.csv(&quot;../02.data/Functional_Precision_Medicine_RNAseq_samples.csv&quot;, header = T) # AML sample ids over_id &lt;- data.frame(intersect(colnames(func_drug), sampleid$sample)) colnames(over_id) &lt;- &quot;sample&quot; func_drug &lt;- func_drug[, c(&quot;Drug_name&quot;, as.character(over_id$sample))] row.names(func_drug) &lt;- func_drug$Drug_name func_drug &lt;- func_drug[, -1] func_drug &lt;- func_drug[, colSums(is.na(func_drug)) == 0] #### heatmap core_mat &lt;- func_drug core_mat1 &lt;- as.matrix(core_mat) bk &lt;- unique(c(seq(-2,2, length=100))) out &lt;- pheatmap( core_mat1, cutree_cols = 2, color = colorRampPalette(c(&quot;#4292C6&quot;, &quot;#F0F0F0&quot;, &quot;#A50F15&quot;))(100), scale = &quot;row&quot;, border_color = &quot;black&quot;, angle_col = &quot;90&quot;, # Column label angle (must be character) show_rownames = TRUE, show_colnames = FALSE, na_col = &quot;grey&quot;, # Color for NA values (instead of na.rm) clustering_method = &quot;ward.D2&quot;, cluster_cols = TRUE, cluster_rows = TRUE ) print(out) col_cluster &lt;- cutree(out$tree_col, k=2) newOrder &lt;- core_mat1[,out$tree_col$order] newOrder &lt;- t(newOrder) # write.csv(newOrder, &quot;../03.out/figure1/02.FPMTB_exVivo_Resistant_Sensitive_HeatmapOrder.csv&quot;) # Order of clustered samples clust_sample &lt;- colnames(core_mat1[, out$tree_col[[&quot;order&quot;]]]) clust_sample &lt;- data.frame(clust_sample) sample_cluster &lt;- data.frame(cutree(out$tree_col, k=2)) colnames(sample_cluster) &lt;- &quot;Cluster&quot; data &lt;- cbind(t(core_mat), sample_cluster) data$group &lt;- ifelse(data$Cluster == 1, &quot;Resistant&quot;, &quot;Sensitive&quot;) table(data$group) ## ## Resistant Sensitive ## 43 55 # write.csv(data, &quot;../03.out/figure1/01.FPMTB_exVivo_Resistant_Sensitive_Raw.csv&quot;) sample_cluster$Group &lt;- ifelse(sample_cluster$Cluster == 1, &quot;Resistant&quot;, &quot;Sensitive&quot;) annotation_col = data.frame( Group = factor(sample_cluster$Group) ) rownames(annotation_col) = colnames(core_mat1) ann_colors = list( Group = c(Sensitive = &quot;#7c9d97&quot;, Resistant = &quot;#e9b383&quot;) ) # pdf(&quot;../03.out/figure1/01.FPMTB_exVivo_drug_heatmap.pdf&quot;, width = 10, height = 6) out &lt;- pheatmap::pheatmap(core_mat1, #breaks = bk, cutree_cols = 3, color = colorRampPalette(c(&quot;#4292C6&quot;, &quot;#F0F0F0&quot;, &quot;#A50F15&quot;))(100), scale = &quot;row&quot;, border_color = &quot;black&quot;, angle_col = 90, show_rownames = TRUE, show_colnames = FALSE, na.rm =TRUE, clustering_method = &quot;ward.D&quot;, annotation_colors = ann_colors, annotation_col = annotation_col, cluster_cols = T, cluster_rows = T ) # dev.off() print(out) clust_sample &lt;- colnames(core_mat1[, out$tree_col[[&quot;order&quot;]]]) clust_sample &lt;- data.frame(clust_sample) sample_cluster &lt;- data.frame(cutree(out$tree_col, k=3)) colnames(sample_cluster) &lt;- &quot;Cluster&quot; data &lt;- cbind(t(core_mat), sample_cluster) data$group &lt;- ifelse(data$Cluster == 1, &quot;Resistant&quot;, &quot;Sensitive&quot;) table(data$Cluster) ## ## 1 2 3 ## 43 27 28 # write.csv(data, &quot;../03.out/figure1/01.FPMTB_exVivo_Resistant_Sensitive_Raw.csv&quot;) # Extract scaled values from the heatmap object # Create matrix and scale manually (same scaling as pheatmap uses) core_matrix &lt;- as.matrix(core_mat1) scale_rows &lt;- function(x) { m &lt;- apply(x, 1, mean, na.rm = TRUE) s &lt;- apply(x, 1, sd, na.rm = TRUE) return((x - m) / s) } scaled_matrix &lt;- scale_rows(core_matrix) # Get cluster assignments (k=3) cluster_assignments &lt;- data.frame(Cluster = cutree(out$tree_col, k = 3)) # Combine scaled values with cluster assignments result_data &lt;- cbind(t(scaled_matrix), cluster_assignments) # write.csv(result_data, &quot;../03.out/figure1/00.FPMTB_exVivo_scaled_scores_with_clusters.csv&quot;) "],["boxplot-for-drug-sensitivity-between-resistant-and-sensitive.html", "2.3 Boxplot for drug sensitivity between resistant and sensitive", " 2.3 Boxplot for drug sensitivity between resistant and sensitive library(ggplot2) library(ggpubr) library(RColorBrewer) library(tidyverse) library(ggrastr) library(ggbeeswarm) ## Group (Resistant vs. Sensitive) mat &lt;- read.csv(&quot;../03.out/figure1/01.FPMTB_exVivo_Resistant_Sensitive_Raw.csv&quot;, header = T, row.names = 1) mat &lt;- mat[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;, &quot;group&quot;)] mat &lt;- mat %&gt;% gather(-&quot;group&quot;, key = &quot;drug&quot;, value = &quot;sDSS&quot;) p &lt;- ggplot(mat, aes(x = group, y = sDSS, color = group)) + geom_boxplot_jitter() + geom_quasirandom(width=0.15, alpha = 0.5) + facet_wrap(.~drug) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Drug sensitivity (sDSS)&quot;) + theme(strip.text.x = element_text(size=13)) + stat_compare_means(comparisons = list(c(&#39;Resistant&#39;, &#39;Sensitive&#39;)), method=&#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position=&#39;None&#39;) print(p) # ggsave(p, filename = &quot;../03.out/figure1/02.FPMTB_Resistant_Sensitive_DrugsDSS_group.pdf&quot;, width = 6, height = 4) ## Cluster (1 2 3) mat &lt;- read.csv(&quot;../03.out/figure1/01.FPMTB_exVivo_Resistant_Sensitive_Raw.csv&quot;, header = T, row.names = 1) mat &lt;- mat[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;, &quot;Cluster&quot;)] mat &lt;- mat %&gt;% gather(-&quot;Cluster&quot;, key = &quot;drug&quot;, value = &quot;sDSS&quot;) mat$Cluster &lt;- as.factor(mat$Cluster) p1 &lt;- ggplot(mat, aes(x = Cluster, y = sDSS, color = Cluster)) + geom_boxplot_jitter() + geom_quasirandom(width=0.15, alpha = 0.5) + facet_wrap(.~drug) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Drug sensitivity (sDSS)&quot;) + theme(strip.text.x = element_text(size=13)) + stat_compare_means(comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method=&#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) + theme(legend.position=&#39;None&#39;) print(p1) # ggsave(p1, filename = &quot;../03.out/figure1/02.FPMTB_Resistant_Sensitive_DrugsDSS_Cluster.pdf&quot;, width = 6, height = 4) ################################### ####### Scaled sensitivity scores ################################### # Clusters (1, 2, 3) drug_sensitivity_cluster &lt;- read.csv(&quot;../03.out/figure1/00.FPMTB_exVivo_scaled_scores_with_clusters.csv&quot;, header = TRUE, row.names = 1) drug_sensitivity_cluster &lt;- drug_sensitivity_cluster[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;, &quot;Cluster&quot;)] drug_sensitivity_cluster &lt;- gather(drug_sensitivity_cluster, -Cluster, key = &quot;drug&quot;, value = &quot;sDSS&quot;) drug_sensitivity_cluster$Cluster &lt;- as.factor(drug_sensitivity_cluster$Cluster) p2 &lt;- ggplot(drug_sensitivity_cluster, aes(x = Cluster, y = sDSS, color = Cluster)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~drug) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Scaled Drug sensitivity (sDSS)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) + theme(legend.position = &#39;None&#39;) print(p2) # ggsave(p2, filename = &quot;../03.out/figure1/02.FPMTB_Resistant_Sensitive_DrugsDSS_Cluster_scaled.pdf&quot;, width = 6, height = 4) "],["de-analysis-functional_medicine.html", "2.4 DE analysis Functional_medicine", " 2.4 DE analysis Functional_medicine # library(dplyr) # library(DESeq2) # source(&quot;RunDESeq2.R&quot;) # newOrder &lt;- read.csv(&quot;../03.out/figure1/01.FPMTB_exVivo_Resistant_Sensitive_Raw.csv&quot;, header = T, row.names = 1) # newOrder &lt;- newOrder[order(newOrder$group, decreasing = FALSE), ] # table(newOrder$group) # tpm &lt;- read.csv(&quot;../02.data/File_8_RNA_seq_TPM_163S_4Healthy.csv&quot;, header=T) # mat &lt;- read.csv(&quot;../02.data/File_8_RNA_seq_Raw_Reads_163S_4Healthy.csv&quot;, header=TRUE) # mat &lt;- merge(tpm[, 1:3], mat, by = &quot;X&quot;) # mat &lt;- subset(mat, Type == &quot;protein_coding&quot;) # tpm &lt;- tpm[which(rowMeans(tpm[, -c(1:3)])&gt;0.1), ] # row.names(mat) &lt;- mat$X # mat &lt;- mat[, -c(1:3)] # colnames(tpm)[1] &lt;- &quot;ID&quot; # overlap_sample &lt;- intersect(row.names(newOrder), colnames(mat)) # newOrder &lt;- newOrder[overlap_sample,] # table(newOrder$group) # mat &lt;- mat[, as.character(row.names(newOrder))] # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(row.names(newOrder)))] # gs &lt;- read.table(&quot;../03.out/figure3/84_gene.txt&quot;, header = F) # # RunDESeq2(count_mat = mat, n.cont = 43, n.treat = 55, # prefix = &quot;../03.out/figure1/FPMTB_DESeq2_out_coding_fillterLow&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) "],["valcanoplot-plot-ex-vivo.html", "2.5 Valcanoplot plot (Ex vivo)", " 2.5 Valcanoplot plot (Ex vivo) source(&quot;plotVolcanoV3.R&quot;) m1 &lt;- read.table(&quot;../03.out/figure1/FPMTB_DESeq2_out_coding_fillterLow_with_normalized_mat.txt&quot;, header = T) m2 &lt;- m1[,1:9] # write.csv(m2, &quot;../03.out/figure1/FPMTB_DESeq2_out.csv&quot;) degs1 &lt;- subset(m2, abs(log2FoldChange) &gt; 0.5 &amp; padj &lt; 0.05) degs_up &lt;- subset(m2, log2FoldChange &gt; 0.5 &amp; padj &lt; 0.05) degs_down &lt;- subset(m2, log2FoldChange &lt; -0.5 &amp; padj &lt; 0.05) gene_selecte &lt;- &quot;NA&quot; m2$log2FoldChange[m2$log2FoldChange &lt; -4] &lt;- -4 m2$padj[m2$padj &lt; 1e-10] &lt;- 1e-10 p1 &lt;- plotVolcano(mat=m2, gene.col=&quot;Symbol&quot;, x.col=&quot;log2FoldChange&quot;, y.col=&quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1=0.05, y_cut2 = 0.01, x.lim=4, y.lim=10, label=FALSE, title = &quot;AZA+VEN (Ex vivo)&quot;, selected_genes = gene_selecte) + theme_classic() print(p1) # ggsave(p1, filename = &quot;../03.out/figure1/03.FPMTB_valcanoplot.pdf&quot;, width = 4.5, height = 4) "],["heatmap-for-representative-de-genes.html", "2.6 Heatmap for representative DE genes", " 2.6 Heatmap for representative DE genes library(pheatmap) heatmap_data &lt;- read.csv(&quot;../03.out/figure1/FPMTB_heatmap.csv&quot;, header = TRUE, row.names = 1) # Prepare the matrix for heatmap generation core_matrix &lt;- as.matrix(heatmap_data) breaks_seq &lt;- unique(c(seq(-3, 3, length = 100))) # Define sample group annotations sample_groups &lt;- data.frame( Group = factor(c(rep(&quot;Resistant&quot;, 43), rep(&quot;Sensitive&quot;, 55))) ) rownames(sample_groups) &lt;- colnames(core_matrix) # Define colors for annotation groups annotation_colors &lt;- list( Group = c(Sensitive = &quot;#7c9d97&quot;, Resistant = &quot;#e9b383&quot;) ) # Create and save the heatmap # pdf(&quot;../03.out/figure1/Out_FPMTB_heatmap.pdf&quot;, width = 5.5, height = 6) out &lt;- pheatmap(core_matrix, breaks = breaks_seq, cutree_cols = 2, cutree_rows = 2, color = colorRampPalette(c(&quot;#4292C6&quot;, &quot;#F0F0F0&quot;, &quot;#A50F15&quot;))(100), scale = &quot;row&quot;, border_color = &quot;black&quot;, angle_col = 90, show_rownames = TRUE, show_colnames = FALSE, na.rm = TRUE, clustering_method = &quot;ward.D&quot;, annotation_colors = annotation_colors, annotation_col = sample_groups, cluster_cols = FALSE, cluster_rows = TRUE) # dev.off() print(out) "],["cibersortx-results-visualization-ex-vivo.html", "2.7 CIBERSORTx Results Visualization (ex vivo)", " 2.7 CIBERSORTx Results Visualization (ex vivo) library(ggplot2) library(ggpubr) library(RColorBrewer) library(tidyverse) library(ggrastr) library(ggbeeswarm) # Load CIBERSORTx results and filter necessary columns cibersortx_results &lt;- read.csv(&quot;../03.out/figure1/CIBERSORTx_Results_FPMTB.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) cibersortx_results &lt;- cibersortx_results[, c(&quot;LSPC-Primed&quot;, &quot;Mono-like&quot;, &quot;group&quot;)] # Available columns for future use: &quot;LSPC-Quiescent&quot;, &quot;LSPC-Cycle&quot;, &quot;GMP-like&quot;, &quot;ProMono-like&quot;, &quot;cDC-like&quot; # Transform data from wide to long format cibersortx_long &lt;- cibersortx_results %&gt;% gather(-group, key = &quot;cell_type&quot;, value = &quot;Score&quot;) # Generate boxplot for cellular abundance comparison (Resistant vs. Sensitive) p &lt;- ggplot(cibersortx_long, aes(x = group, y = Score, color = group)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~cell_type, ncol = 2) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Cellular abundance (CIBERSORTx)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;Resistant&#39;, &#39;Sensitive&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position = &#39;None&#39;) # Display plot print(p) # Save plot to file # ggsave(p, filename = &quot;../03.out/figure1/Out_FPMTB_Resistant_Sensitive_cibersortx.pdf&quot;, width = 2.5, height = 4.5) "],["cibersortx-results-visualization-in-vivo.html", "2.8 CIBERSORTx Results Visualization (in vivo)", " 2.8 CIBERSORTx Results Visualization (in vivo) library(ggplot2) library(ggpubr) library(RColorBrewer) library(tidyverse) library(ggrastr) library(ggbeeswarm) # Load CIBERSORTx results and filter necessary columns cibersortx_results &lt;- read.csv(&quot;../03.out/figure1/CIBERSORTx_142_Results.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) cibersortx_results &lt;- cibersortx_results[, c(&quot;Mono-like&quot;, &quot;Response&quot;)] cibersortx_results$cell_type &lt;- &quot;Mono-like&quot; # Generate boxplot for cellular abundance comparison (Resistant vs. Sensitive) p &lt;- ggplot(cibersortx_results, aes(x = Response, y = `Mono-like`, color = Response)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~cell_type, ncol = 2) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Mono-like abundance (CIBERSORTx)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;CR&#39;, &#39;NonCR&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position = &#39;None&#39;) # Display plot print(p) cibersortx_results &lt;- read.csv(&quot;../03.out/figure1/CIBERSORTx_142_Results.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) cibersortx_results &lt;- cibersortx_results[, c(&quot;Total LSPC&quot;, &quot;LSPC-Cycle&quot;, &quot;LSPC-Primed&quot;, &quot;LSPC-Quiescent&quot;, &quot;Response&quot;)] # Transform data from wide to long format cibersortx_long &lt;- cibersortx_results %&gt;% gather(-Response, key = &quot;cell_type&quot;, value = &quot;Score&quot;) # Generate boxplot for cellular abundance comparison (Resistant vs. Sensitive) p1 &lt;- ggplot(cibersortx_long, aes(x = Response, y = Score, color = Response)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~cell_type, ncol = 4) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Cellular abundance (CIBERSORTx)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;CR&#39;, &#39;NonCR&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position = &#39;None&#39;) # Display plot print(p1) "],["ssgsea-analysis-in-vivo.html", "2.9 ssGSEA analysis in vivo", " 2.9 ssGSEA analysis in vivo library(GSVA) library(GSEABase) library(patchwork) library(ggpubr) library(tidyverse) library(ggrastr) library(ggbeeswarm) # tpm &lt;- read.csv(&quot;../03.out/figure1/cohort1_2_cibersortx.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # gene.set &lt;- read.csv(&quot;../03.out/figure1/Mono_LSC_genes.csv&quot;, header = T, sep = &quot;,&quot;) # geneSets &lt;- list(Monocyte_Differentiation = gene.set$Monocyte_Differentiation, # LSC_UP = gene.set$LSC_UP) # # tpm &lt;- as.matrix(tpm) # gsvapar &lt;- gsvaParam(tpm, geneSets, maxDiff=TRUE) # gsva_es &lt;- gsva(gsvapar) # gsva_es &lt;- data.frame(t(gsva_es)) # gsva_es$Sample &lt;- row.names(gsva_es) # # clinic &lt;- read.csv(&quot;../03.out/figure1/CIBERSORTx_142_Results.csv&quot;, header = TRUE, check.names = FALSE) # clinic &lt;- clinic[, c(&quot;Sample&quot;, &quot;Response&quot;)] # # gsva_es &lt;- merge(gsva_es, clinic, by = &quot;Sample&quot;) # write.csv(gsva_es, &quot;../03.out/figure1/gsva_es.out.csv&quot;) gsva_es &lt;- read.csv(&quot;../03.out/figure1/gsva_es.out.csv&quot;, header = T) # Transform data from wide to long format gsva_es_long &lt;- gsva_es[, -1] %&gt;% gather(-Response, key = &quot;cell_type&quot;, value = &quot;Score&quot;) # Generate boxplot for cellular abundance comparison (Resistant vs. Sensitive) p2 &lt;- ggplot(gsva_es_long, aes(x = Response, y = Score, color = Response)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~cell_type, ncol = 2, scales = &quot;free&quot;) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Signature score (ssGSEA)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;CR&#39;, &#39;NonCR&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position = &#39;None&#39;) print(p2) "],["go-enrichment-dot-plot.html", "2.10 GO Enrichment Dot Plot", " 2.10 GO Enrichment Dot Plot library(ggplot2) go_enrichment_data &lt;- read.csv(&quot;../03.out/figure1/Metascape_DEGs_plot.csv&quot;, header = TRUE) # Reorder factor levels based on GO description go_enrichment_data$Description &lt;- factor(go_enrichment_data$Description, levels = rev(go_enrichment_data$Description)) # Generate dot plot for GO enrichment results p &lt;- ggplot(go_enrichment_data, aes(x = NA, y = Description, color = Z.score, size = negLogP)) + geom_point(stroke = 1) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_classic() + scale_color_gradient(low = &quot;#DADAEB&quot;, high = &quot;#7582c1&quot;) + scale_size(&quot;negLogP&quot;, limits = c(5, 18), range = c(2, 6)) + theme_bw() + theme(axis.text.x = element_text(angle = 45)) # Display plot print(p) # Save plot to file # ggsave(p, filename = &quot;figure1/Out_DEGs_enrichment_dotplot.pdf&quot;, width = 4, height = 5) "],["figure-2.html", "Chapter 3 Figure 2", " Chapter 3 Figure 2 Multi-omic data integration identifies the core genes associated with venetoclax-azacitidine response "],["de-analysis-between-in-vivo-sensitive-and-resistant.html", "3.1 DE analysis between in vivo sensitive and resistant", " 3.1 DE analysis between in vivo sensitive and resistant ##################################################### ### Kaplan-Meier (KM) Plots for RJAML Cohort 1 ##################################################### library(ggplot2) library(survminer) library(survival) # Load data data &lt;- read_xlsx(&quot;../02.data/01.110_AZA_VEN_RNAseq_ClinicalMut.xlsx&quot;) group_counts &lt;- table(data$Response) legend_labs &lt;- c(paste0(&quot;Non-CR/CRi (N = &quot;, group_counts[&quot;0&quot;], &quot;)&quot;), paste0(&quot;CR/CRi (N = &quot;, group_counts[&quot;1&quot;], &quot;)&quot;)) # Event-Free Survival (EFS) - Calculate C-index and HR fit_efs &lt;- survfit(Surv(EFS_Time, EFS_Status) ~ Response, data = data) cox_model_efs &lt;- coxph(Surv(EFS_Time, EFS_Status) ~ Response, data = data) c_index_efs &lt;- summary(cox_model_efs)$concordance[1] hr_efs &lt;- exp(coef(cox_model_efs))[1] hr_ci_efs &lt;- exp(confint(cox_model_efs))[1, ] hr_label_efs &lt;- paste0(&quot;HR: &quot;, round(hr_efs, 2), &quot; (95% CI: &quot;, round(hr_ci_efs[1], 2), &quot; - &quot;, round(hr_ci_efs[2], 2), &quot;)&quot;) c_index_label_efs &lt;- paste0(&quot;C-index: &quot;, round(c_index_efs, 3)) # Generate KM plot for EFS p1 &lt;- ggsurvplot(fit_efs, data = data, pval = TRUE, conf.int = FALSE, risk.table = TRUE, font.legend = 13, legend.title = &quot;Response&quot;, legend = c(0.75, 0.85), xlab = &#39;Survival time (years)&#39;, ylab = &#39;Survival probability (EFS)&#39;, legend.labs = legend_labs) + labs(caption = paste0(c_index_label_efs, &quot;\\n&quot;, hr_label_efs)) # Save EFS KM plot # pdf(&quot;../03.figure2/01.rjaml_c1_EFS.pdf&quot;, width = 5, height = 5.5, onefile = FALSE) print(p1) # dev.off() # Overall Survival (OS) - Calculate C-index and HR fit_os &lt;- survfit(Surv(OS_Time, OS_Status) ~ Response, data = data) cox_model_os &lt;- coxph(Surv(OS_Time, OS_Status) ~ Response, data = data) c_index_os &lt;- summary(cox_model_os)$concordance[1] hr_os &lt;- exp(coef(cox_model_os))[1] hr_ci_os &lt;- exp(confint(cox_model_os))[1, ] hr_label_os &lt;- paste0(&quot;HR: &quot;, round(hr_os, 2), &quot; (95% CI: &quot;, round(hr_ci_os[1], 2), &quot; - &quot;, round(hr_ci_os[2], 2), &quot;)&quot;) c_index_label_os &lt;- paste0(&quot;C-index: &quot;, round(c_index_os, 3)) # Generate KM plot for OS p2 &lt;- ggsurvplot(fit_os, data = data, pval = TRUE, conf.int = FALSE, risk.table = TRUE, font.legend = 13, legend.title = &quot;Response&quot;, legend = c(0.75, 0.85), xlab = &#39;Survival time (years)&#39;, ylab = &#39;Survival probability (OS)&#39;, legend.labs = legend_labs) + labs(caption = paste0(c_index_label_os, &quot;\\n&quot;, hr_label_os)) # Save OS KM plot # pdf(&quot;../03.figure2/01.rjaml_c1_OS.pdf&quot;, width = 5, height = 5.5, onefile = FALSE) print(p2) # dev.off() "],["de-analysis-rjaml-azaven-cohort.html", "3.2 DE analysis RJAML AZA+VEN cohort", " 3.2 DE analysis RJAML AZA+VEN cohort # library(dplyr) # library(DESeq2) # source(&quot;RunDESeq2.R&quot;) # tpm &lt;- read.table(&quot;../02.data/rjaml_TPM_matrix.txt&quot;, header=TRUE, check.names = FALSE) # mat &lt;- read.table(&quot;../02.data/rjaml_count_matrix.txt&quot;, header=TRUE, row.names = 1, check.names = FALSE) # sample &lt;- read.csv(&quot;../02.data/rjaml_rnaseq_group.csv&quot;, header = TRUE, check.names = FALSE) # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample$SampleID))] # mat &lt;- mat[, as.character(sample$SampleID)] # tpm &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0.5), ] # 33 Non-CR/CRi 77 CR/CRi # RunDESeq2(count_mat = mat, n.cont = 33, n.treat = 77, # prefix = &quot;../03.out/figure2/rjaml_DESeq2_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) "],["valcanoplot-plot-ex-vivo-1.html", "3.3 Valcanoplot plot (Ex vivo)", " 3.3 Valcanoplot plot (Ex vivo) source(&quot;plotVolcanoV3.R&quot;) m1 &lt;- read.table(&quot;../03.out/figure1/FPMTB_DESeq2_out_coding_fillterLow_with_normalized_mat.txt&quot;, header = T) m2 &lt;- m1[,1:9] # write.csv(m2, &quot;../03.out/figure1/FPMTB_DESeq2_out.csv&quot;) degs1 &lt;- subset(m2, abs(log2FoldChange) &gt; 0.5 &amp; padj &lt; 0.05) degs_up &lt;- subset(m2, log2FoldChange &gt; 0.5 &amp; padj &lt; 0.05) degs_down &lt;- subset(m2, log2FoldChange &lt; -0.5 &amp; padj &lt; 0.05) gene_selecte &lt;- &quot;NA&quot; m2$log2FoldChange[m2$log2FoldChange &lt; -4] &lt;- -4 m2$padj[m2$padj &lt; 1e-10] &lt;- 1e-10 p1 &lt;- plotVolcano(mat=m2, gene.col=&quot;Symbol&quot;, x.col=&quot;log2FoldChange&quot;, y.col=&quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1=0.05, y_cut2 = 0.01, x.lim=4, y.lim=10, label=FALSE, title = &quot;AZA+VEN (Ex vivo)&quot;, selected_genes = gene_selecte) + theme_classic() print(p1) # ggsave(p1, filename = &quot;../03.out/figure1/03.FPMTB_valcanoplot.pdf&quot;, width = 4.5, height = 4) "],["valcanoplot-plot-in-vivo.html", "3.4 Valcanoplot plot (In vivo)", " 3.4 Valcanoplot plot (In vivo) source(&quot;plotVolcanoV3.R&quot;) m3 &lt;- read.table(&quot;../03.out/figure2/rjaml_DESeq2_out_with_normalized_mat.txt&quot;, header = T) m4 &lt;- m3[,1:9] # write.csv(m4, &quot;../03.out/figure1/rjaml_DESeq2_out_DE_Outs.csv&quot;) degs2 &lt;- subset(m4, abs(log2FoldChange) &gt; 0.5 &amp; padj &lt; 0.05) degs_up2 &lt;- subset(m4, log2FoldChange &gt; 0.5 &amp; padj &lt; 0.05) degs_down2 &lt;- subset(m4, log2FoldChange &lt; -0.5 &amp; padj &lt; 0.05) gene_selecte &lt;- &quot;NA&quot; m4$log2FoldChange[m4$log2FoldChange &lt; -4] &lt;- -4 m4$log2FoldChange[m4$log2FoldChange &gt; 4] &lt;- 4 m4$padj[m4$padj &lt; 1e-8] &lt;- 1e-8 p2 &lt;- plotVolcano(mat=m4, gene.col=&quot;Symbol&quot;, x.col=&quot;log2FoldChange&quot;, y.col=&quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1=0.05, y_cut2 = 0.01, x.lim=4, y.lim=8, label=FALSE, title = &quot;AZA+VEN (In vivo)&quot;, selected_genes = gene_selecte) + theme_classic() print(p2) # ggsave(p, filename = &quot;../03.out/figure1/04.RJAML_valcanoplot.pdf&quot;, width = 4.5, height = 4) "],["venn-plot.html", "3.5 Venn plot", " 3.5 Venn plot library(ggvenn) library(patchwork) # Function to create Venn diagram and perform hypergeometric test create_venn_plot &lt;- function(gene_list1, gene_list2, labels, colors, N) { # Convert to vectors and remove NAs and duplicates gene_list1 &lt;- na.omit(unique(as.vector(gene_list1))) gene_list2 &lt;- na.omit(unique(as.vector(gene_list2))) # Print the lengths of the gene lists cat(&quot;Length of&quot;, labels[1], &quot;:&quot;, length(gene_list1), &quot;\\n&quot;) cat(&quot;Length of&quot;, labels[2], &quot;:&quot;, length(gene_list2), &quot;\\n&quot;) # Check if gene lists are not empty if (length(gene_list1) == 0 || length(gene_list2) == 0) { warning(&quot;One or both gene lists are empty. Cannot create Venn diagram.&quot;) return(NULL) } # Create a list of gene sets and assign names gene_lists &lt;- list(gene_list1, gene_list2) names(gene_lists) &lt;- labels # Create Venn diagram venn_plot &lt;- ggvenn( gene_lists, fill_color = colors, stroke_size = 0.5, set_name_size = 4, auto_scale = FALSE ) # Calculate sizes and overlap geneset1_size &lt;- length(gene_list1) geneset2_size &lt;- length(gene_list2) overlap &lt;- length(intersect(gene_list1, gene_list2)) # Print overlap information cat(&quot;Overlap between&quot;, labels[1], &quot;and&quot;, labels[2], &quot;:&quot;, overlap, &quot;genes\\n&quot;) # Perform hypergeometric test p_value &lt;- phyper( overlap - 1, geneset2_size, N - geneset2_size, geneset1_size, lower.tail = FALSE ) # Add p-value annotation to the plot venn_plot &lt;- venn_plot + annotate( &quot;text&quot;, x = 0, y = 1, label = paste0(&quot;P-value = &quot;, signif(p_value, 3)), colour = &quot;black&quot; ) # Return the plot return(venn_plot) } # Define total number of genes in the background (e.g., human genome) N &lt;- 20000 ## Gene lists for DEGs degs_list1 &lt;- degs1$Symbol degs_list2 &lt;- degs2$Symbol ## Labels and colors for DEGs labels_degs &lt;- c(&quot;AZA+VEN (Ex vivo)&quot;, &quot;AZA+VEN (In vivo)&quot;) colors_degs &lt;- c(&quot;#868686FF&quot;, &quot;#CD534CFF&quot;) p0 &lt;- create_venn_plot(degs_list1, degs_list2, labels_degs, colors_degs, N) ## Length of AZA+VEN (Ex vivo) : 1626 ## Length of AZA+VEN (In vivo) : 1115 ## Overlap between AZA+VEN (Ex vivo) and AZA+VEN (In vivo) : 130 genes ## Gene lists for up-regulated genes degs_up_list1 &lt;- degs_up$Symbol degs_up_list2 &lt;- degs_up2$Symbol ## Labels and colors for up-regulated genes labels_up &lt;- c(&quot;AZA+VEN (Ex vivo) UP&quot;, &quot;AZA+VEN (In vivo) UP&quot;) colors_up &lt;- c(&quot;#0073C2FF&quot;, &quot;#EFC000FF&quot;) ## Create up-regulated gene Venn diagram p1 &lt;- create_venn_plot(degs_up_list1, degs_up_list2, labels_up, colors_up, N) ## Length of AZA+VEN (Ex vivo) UP : 411 ## Length of AZA+VEN (In vivo) UP : 523 ## Overlap between AZA+VEN (Ex vivo) UP and AZA+VEN (In vivo) UP : 14 genes ## Gene lists for down-regulated genes degs_down_list1 &lt;- degs_down$Symbol degs_down_list2 &lt;- degs_down2$Symbol ## Labels and colors for down-regulated genes labels_down &lt;- c(&quot;AZA+VEN (Ex vivo) DN&quot;, &quot;AZA+VEN (In vivo) DN&quot;) colors_down &lt;- c(&quot;#868686FF&quot;, &quot;#CD534CFF&quot;) ## Create down-regulated gene Venn diagram p2 &lt;- create_venn_plot(degs_down_list1, degs_down_list2, labels_down, colors_down, N) ## Length of AZA+VEN (Ex vivo) DN : 1215 ## Length of AZA+VEN (In vivo) DN : 593 ## Overlap between AZA+VEN (Ex vivo) DN and AZA+VEN (In vivo) DN : 70 genes plots &lt;- p0 | p1 | p2 print(plots) ## Save the plots to a PDF file # ggsave(plots, filename = &quot;../03.out/figure1/05.vennPlots.pdf&quot;, width = 9, height = 3) "],["integration-of-degs-ex-vivo-and-in-vivo.html", "3.6 Integration of DEGs ex vivo and in vivo", " 3.6 Integration of DEGs ex vivo and in vivo library(ggplot2) library(ggrepel) overlap_gene &lt;- intersect(degs1$Symbol, degs2$Symbol) degs_exvivo &lt;- subset(m2, Symbol %in% overlap_gene)[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;log2FoldChange&quot;, &quot;padj&quot;)] degs_invivo &lt;- subset(m4, Symbol %in% overlap_gene)[, c(&quot;log2FoldChange&quot;, &quot;padj&quot;)] degs &lt;- cbind(degs_exvivo, degs_invivo) colnames(degs) &lt;- c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;ExVivo_log2FC&quot;, &quot;ExVivo_padj&quot;, &quot;InVivo_log2FC&quot;, &quot;InVivo_padj&quot;) degs$ExVivo_neg_log10_padj &lt;- -log10(degs$ExVivo_padj) degs$InVivo_neg_log10_padj &lt;- -log10(degs$InVivo_padj) degs$quadrant &lt;- with(degs, ifelse(ExVivo_log2FC &gt; 0.5 &amp; InVivo_log2FC &gt; 0.5, &quot;x &gt; 0.5 &amp; y &gt; 0.5&quot;, ifelse(ExVivo_log2FC &lt; -0.5 &amp; InVivo_log2FC &lt; -0.5, &quot;x &lt; -0.5 &amp; y &lt; -0.5&quot;, ifelse(ExVivo_log2FC &gt; 0.5 &amp; InVivo_log2FC &lt; -0.5, &quot;x &gt; 0.5 &amp; y &lt; -0.5&quot;, &quot;x &lt; -0.5 &amp; y &gt; 0.5&quot;)))) genes_to_label &lt;- c(&quot;BCL2L1&quot;, &quot;PINK1&quot;, &quot;CEBPE&quot;, &quot;CSMD3&quot;, &quot;HPSE2&quot;, &quot;CD177&quot;, &quot;ROBO2&quot;, &quot;TEAD2&quot;, &quot;CLEC2L&quot;, &quot;TPSAB1&quot;, &quot;USP44&quot;, &quot;SLC9A3&quot;, &quot;CEBPA&quot;, &quot;MANEAL&quot;) degs$label &lt;- ifelse(degs$Symbol %in% genes_to_label, degs$Symbol, NA) p &lt;- ggplot(degs, aes(x = ExVivo_log2FC, y = InVivo_log2FC)) + # Plot points with size mapped to combined significance and color mapped to quadrant geom_point(aes(size = ExVivo_neg_log10_padj + InVivo_neg_log10_padj, color = quadrant), alpha = 0.6) + # Add dashed lines at x = +-0.5 and y = +-0.5 geom_vline(xintercept = c(-0.5, 0.5), linetype = &quot;dashed&quot;, color = &quot;black&quot;) + geom_hline(yintercept = c(-0.5, 0.5), linetype = &quot;dashed&quot;, color = &quot;black&quot;) + # Customize color mapping for the four quadrants scale_color_manual(values = c(&quot;x &gt; 0.5 &amp; y &gt; 0.5&quot; = &quot;#006CAF&quot;, &quot;x &lt; -0.5 &amp; y &lt; -0.5&quot; = &quot;#D078A7&quot;, &quot;x &gt; 0.5 &amp; y &lt; -0.5&quot; = &quot;#A09D9B&quot;, &quot;x &lt; -0.5 &amp; y &gt; 0.5&quot; = &quot;#00976A&quot;)) + geom_label_repel(aes(label = label), size = 4, box.padding = 0.35, point.padding = 0.5, segment.color = &#39;grey50&#39;, arrow = arrow(length = unit(0.02, &quot;npc&quot;)), segment.size = 0.5, label.size = 0.5, color = &quot;black&quot;, fill = &quot;white&quot;) + labs(x = &quot;Log2 FoldChange \\n(Ex vivo, CR/CRi vs. Non-CR/CRi)&quot;, y = &quot;Log2 FoldChange \\n(In vivo, CR/CRi vs. Non-CR/CRi)&quot;, size = &quot;-log10(padj)&quot;, color = &quot;Quadrant&quot;) + theme_bw() print(p) # ggsave(p, filename = &quot;../03.out/figure1/06.inteDotplot.pdf&quot;, width = 5.8, height = 4) "],["gsea-analysis-for-crispri-drug-sensitivity.html", "3.7 GSEA analysis for CRISPRi drug sensitivity", " 3.7 GSEA analysis for CRISPRi drug sensitivity library(tidyverse) library(dplyr) library(GseaVis) library(ggpubr) library(patchwork) library(clusterProfiler) library(enrichplot) ## VEN screening DE_list &lt;- read.csv(&quot;../02.data/CRISPR_Ven.csv&quot;, header = T) DE_list &lt;- DE_list[, c(1,2)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- data.frame(term = c(rep(&quot;AZA_Ven_Sensitive_DN&quot;, length(intersect(degs_down$Symbol, degs_down2$Symbol))), rep(&quot;AZA_Ven_Sensitive_UP&quot;, length(intersect(degs_up$Symbol, degs_up2$Symbol))) ), gene = c(intersect(degs_down$Symbol, degs_down2$Symbol), intersect(degs_up$Symbol, degs_up2$Symbol)) ) table(geneSet$term) ## ## AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_UP ## 70 14 set.seed(123456) gsea.enrich &lt;- GSEA(geneList, TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 1100, pAdjustMethod = &quot;BH&quot;, seed = TRUE, eps = 0) gsea.enrich@result ## ID Description setSize ## AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_DN 70 ## AZA_Ven_Sensitive_UP AZA_Ven_Sensitive_UP AZA_Ven_Sensitive_UP 13 ## enrichmentScore NES pvalue p.adjust ## AZA_Ven_Sensitive_DN -0.4548245 -1.7837329 0.0005862015 0.001172403 ## AZA_Ven_Sensitive_UP -0.2450449 -0.6468185 0.8963210702 0.896321070 ## qvalues rank leading_edge ## AZA_Ven_Sensitive_DN 0.0006170543 5358 tags=50%, list=28%, signal=36% ## AZA_Ven_Sensitive_UP 0.4717479317 4696 tags=31%, list=25%, signal=23% ## core_enrichment ## AZA_Ven_Sensitive_DN FIGN/LIPE/ARG2/PGF/CD177/CSF1/SFRP2/MXI1/EDIL3/MICALCL/ADIPOR1/TMEM45A/CSMD3/GABRD/KLC3/XK/TMEM158/SASH1/HBQ1/TRIM58/NATD1/ARHGEF12/GNB3/PHOSPHO1/ROGDI/HBE1/EPHB1/C10orf131/TSPAN5/PLXNA4/PGLYRP1/ROBO2/LAMA2/BCL2L1/PINK1 ## AZA_Ven_Sensitive_UP PTGFRN/CLEC2L/TPSAB1/CNTN1 # pdf(&quot;../03.out/figure2/07.CRISPRi_gsea_VEN.pdf&quot;, width = 6, height = 6.5) gseaplot(gsea.enrich, pvalue_table = TRUE, geneSetID = c(&quot;AZA_Ven_Sensitive_DN&quot;)) # dev.off() ## 5-AZA screening DE_list &lt;- read.csv(&quot;../02.data/CRISPR_Ven.csv&quot;, header = T) DE_list &lt;- DE_list[, c(1,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- data.frame(term = c(rep(&quot;AZA_Ven_Sensitive_DN&quot;, length(intersect(degs_down$Symbol, degs_down2$Symbol))), rep(&quot;AZA_Ven_Sensitive_UP&quot;, length(intersect(degs_up$Symbol, degs_up2$Symbol))) ), gene = c(intersect(degs_down$Symbol, degs_down2$Symbol), intersect(degs_up$Symbol, degs_up2$Symbol)) ) table(geneSet$term) ## ## AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_UP ## 70 14 set.seed(123456) gsea.enrich &lt;- GSEA(geneList, TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 1100, pAdjustMethod = &quot;BH&quot;, seed = TRUE, eps = 0) gsea.enrich@result ## ID Description setSize ## AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_DN AZA_Ven_Sensitive_DN 70 ## AZA_Ven_Sensitive_UP AZA_Ven_Sensitive_UP AZA_Ven_Sensitive_UP 13 ## enrichmentScore NES pvalue p.adjust qvalues rank ## AZA_Ven_Sensitive_DN -0.3203249 -1.268860 0.1038760 0.2077519 0.2077519 4705 ## AZA_Ven_Sensitive_UP -0.3053435 -0.814603 0.7198582 0.7198582 0.7198582 3380 ## leading_edge ## AZA_Ven_Sensitive_DN tags=33%, list=25%, signal=25% ## AZA_Ven_Sensitive_UP tags=31%, list=18%, signal=25% ## core_enrichment ## AZA_Ven_Sensitive_DN TMEM45A/TRIM58/TEAD2/PPP1R13B/LIPE/FAM210B/CSF1/DNAJC6/JSRP1/PI3/TTC39A/XK/HBM/PINK1/HBQ1/ARHGEF12/CCNDBP1/AFAP1/CSMD3/TMEM63C/TSPAN5/CDH5/LANCL3 ## AZA_Ven_Sensitive_UP TPSAB1/CIB3/SLC9A3/MPDZ # pdf(&quot;../03.out/figure2/07.CRISPRi_gsea_AZA.pdf&quot;, width = 6, height = 6.5) out &lt;- gseaplot(gsea.enrich, pvalue_table = TRUE, geneSetID = c(&quot;AZA_Ven_Sensitive_DN&quot;)) # dev.off() print(out) "],["differential-expression-analysis-for-shpink1.html", "3.8 Differential Expression Analysis for shPINK1", " 3.8 Differential Expression Analysis for shPINK1 ########################################################################## ### Differential Expression Analysis for shPINK1 ########################################################################## # library(GenomicFeatures) # library(stringr) # dir &lt;- &quot;../02.data/&quot; # setwd(dir) # files &lt;- list.files(dir, pattern = &quot;.count&quot;, recursive=TRUE) # count.files &lt;- list() # # for(i in 1:length(files)){ # count.files[[i]] &lt;- read.table(files[[i]], header=FALSE, sep=&quot;\\t&quot;, row.names=1) # } # count.matrix &lt;- do.call(cbind, count.files) # colnames &lt;- gsub(&quot;.count&quot;, &quot;&quot;, files) # colnames(count.matrix) &lt;- colnames # count.matrix &lt;- count.matrix[1:60483, ] # ## Save the count table # write.table(count.matrix, &quot;../03.out/figure2/shPINK1_count.matrix.txt&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=NA, quote=FALSE) # # gtffile &lt;- &quot;gencode.v22.annotation.gtf.gz&quot; # txdb &lt;- makeTxDbFromGFF(gtffile, format=&quot;gtf&quot;) # ebg &lt;- exonsBy(txdb, by=&quot;gene&quot;) # ebgList &lt;- sum(width(reduce(ebg))) # genes &lt;- intersect(rownames(count.matrix), names(ebgList)) # Length &lt;- as.vector(ebgList[genes]) # Length &lt;- as.vector(Length) # ## Normalize # TPM &lt;- t(t(count.matrix / t(Length)) * 1e6 / colSums(count.matrix / t(Length))) # TPM &lt;- data.frame(TPM) # TPM$ID &lt;- row.names(TPM) # ## gene anno # anno &lt;- read.table(&quot;geneAnnotation.txt&quot;, header = F) # colnames(anno) &lt;- c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;) # tpm &lt;- merge(anno, TPM, by = &quot;ID&quot;) # write.table(tpm, &quot;../03.out/figure2/shPINK1_ID_matched_TPM_matrix.txt&quot;) #### #### PCA analysis #### library(ggplot2) library(dplyr) library(ggfortify) library(plotly) library(scatterplot3d) tpm &lt;- read.table(&quot;../03.out/figure2/shPINK1_ID_matched_TPM_matrix.txt&quot;, header = TRUE, check.names = FALSE) ## MOLM13 cell lines dat &lt;- tpm[, 4:9] row.names(dat) &lt;- tpm$ID dat &lt;- dat[which(rowMeans(dat[, -c(1:3)]) &gt; 0), ] scaled_matrix &lt;- scale(t(dat)) pca_result &lt;- prcomp(scaled_matrix, scale. = TRUE) # Create a grouping vector groups &lt;- c(rep(&quot;Scramble&quot;, 2), rep(&quot;shPINK1-1&quot;, 2), rep(&quot;shPINK1-2&quot;, 2)) pca_2d_df &lt;- as.data.frame(pca_result$x) pca_2d_df$Group &lt;- groups # Define colors for groups group_colors &lt;- c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) names(group_colors) &lt;- unique(groups) # Add variance explained for axis labels explained_variance &lt;- summary(pca_result)$importance[2, ] x_label &lt;- paste0(&quot;PC1 (&quot;, round(explained_variance[1] * 100, 2), &quot;%)&quot;) y_label &lt;- paste0(&quot;PC2 (&quot;, round(explained_variance[2] * 100, 2), &quot;%)&quot;) # pdf(&quot;../03.out/figure2/shPINK1_M13_2D_PCA.pdf&quot;, width = 5.3, height = 4) p &lt;- ggplot(pca_2d_df, aes(x = PC1, y = PC2, color = Group)) + geom_point(size = 3) + scale_color_manual(values = group_colors) + labs( x = paste0(&quot;PC1 (&quot;, round(explained_variance[1] * 100, 2), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(explained_variance[2] * 100, 2), &quot;%)&quot;), title = &quot;MOLM13 cells&quot; ) + theme_classic() + theme(legend.title = element_blank()) + guides(color = guide_legend(title = &quot;Groups&quot;)) # dev.off() print(p) ## OA3 cell lines dat &lt;- tpm[, 10:15] row.names(dat) &lt;- tpm$ID dat &lt;- dat[which(rowMeans(dat[, -c(1:3)]) &gt; 0), ] scaled_matrix &lt;- scale(t(dat)) pca_result &lt;- prcomp(scaled_matrix, scale. = TRUE) # Create a grouping vector groups &lt;- c(rep(&quot;Scramble&quot;, 2), rep(&quot;shPINK1-1&quot;, 2), rep(&quot;shPINK1-2&quot;, 2)) pca_2d_df &lt;- as.data.frame(pca_result$x) pca_2d_df$Group &lt;- groups # Define colors for groups group_colors &lt;- c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) names(group_colors) &lt;- unique(groups) # Add variance explained for axis labels explained_variance &lt;- summary(pca_result)$importance[2, ] x_label &lt;- paste0(&quot;PC1 (&quot;, round(explained_variance[1] * 100, 2), &quot;%)&quot;) y_label &lt;- paste0(&quot;PC2 (&quot;, round(explained_variance[2] * 100, 2), &quot;%)&quot;) # pdf(&quot;../03.out/figure2/shPINK1_OA3_2D_PCA.pdf&quot;, width = 5.3, height = 4) p1 &lt;- ggplot(pca_2d_df, aes(x = PC1, y = PC2, color = Group)) + geom_point(size = 3) + scale_color_manual(values = group_colors) + labs( x = paste0(&quot;PC1 (&quot;, round(explained_variance[1] * 100, 2), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(explained_variance[2] * 100, 2), &quot;%)&quot;), title = &quot;OA3 cells&quot; ) + theme_classic() + theme(legend.title = element_blank()) + guides(color = guide_legend(title = &quot;Groups&quot;)) # dev.off() print(p1) "],["de-analysis-in-cell-lines.html", "3.9 DE analysis in cell lines", " 3.9 DE analysis in cell lines # library(dplyr) # library(DESeq2) # # source(&quot;plotVolcanoV3.R&quot;) # # Load TPM and raw count data # tpm &lt;- read.table(&quot;../03.out/figure2/shPINK1_ID_matched_TPM_matrix.txt&quot;, header = TRUE, check.names = FALSE) # mat &lt;- read.table(&quot;../03.out/figure2/shPINK1_count.matrix.txt&quot;, header = TRUE, row.names = 1, check.names = FALSE) # tpm &lt;- subset(tpm, Type == &quot;protein_coding&quot;) # ## MOLM13 sh1 vs. control # samples &lt;- c(&quot;M0_rep1&quot;, &quot;M0_rep2&quot;, &quot;M1_rep1&quot;, &quot;M1_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 2, # prefix = &quot;../03.out/figure2/M13_sh1_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) # # ## MOLM13 sh2 vs. control # samples &lt;- c(&quot;M0_rep1&quot;, &quot;M0_rep2&quot;, &quot;M2_rep1&quot;, &quot;M2_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 2, # prefix = &quot;../03.out/figure2/M13_sh2_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) # # ## MOLM13 sh1 sh2 vs. control # samples &lt;- c(&quot;M0_rep1&quot;, &quot;M0_rep2&quot;, &quot;M1_rep1&quot;, &quot;M1_rep2&quot;, &quot;M2_rep1&quot;, &quot;M2_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 4, # prefix = &quot;../03.out/figure2/M13_sh12_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) # # # ## OA3 sh1 vs. control # samples &lt;- c(&quot;O0_rep1&quot;, &quot;O0_rep2&quot;, &quot;O1_rep1&quot;, &quot;O1_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 2, # prefix = &quot;../03.out/figure2/OA3_sh1_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) # # ## OA3 sh4 vs. control # samples &lt;- c(&quot;O0_rep1&quot;, &quot;O0_rep2&quot;, &quot;O4_rep1&quot;, &quot;O4_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 2, # prefix = &quot;../03.out/figure2/OA3_sh4_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) # # ## OA3 sh1 sh4 vs. control # samples &lt;- c(&quot;O0_rep1&quot;, &quot;O0_rep2&quot;, &quot;O1_rep1&quot;, &quot;O1_rep2&quot;, &quot;O4_rep1&quot;, &quot;O4_rep2&quot;) # # Filter low-expressed genes # tpm1 &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0), c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, samples)] # mat1 &lt;- mat[tpm1$ID, samples] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat1, n.cont = 2, n.treat = 4, # prefix = &quot;../03.out/figure2/OA3_sh14_control_out&quot;, sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm1) "],["valcano-plots-molm13.html", "3.10 Valcano plots (MOLM13)", " 3.10 Valcano plots (MOLM13) #################################### ######### Valcano plots #################################### library(patchwork) source(&quot;plotVolcano.R&quot;) resis_sen &lt;- read.csv(&quot;../03.out/figure2/selected_genes_resistant_sensitive.csv&quot;, header = T) # gsym Pathway # Gene1 KEGG_RIBOSOME # Gene2 KEGG_DNA_REPLICATION custom_colors &lt;- brewer.pal(4, &quot;BrBG&quot;) # PiYG palette ## MOLM13 ## shRNA1 vs Scramble (control) deseq_output1 &lt;- read.table(&quot;../03.out/figure2/M13_sh1_control_out_with_normalized_mat.txt&quot;, header = T) selected_data1 &lt;- deseq_output1[, 1:9] # Cap log2 fold changes at 5 to avoid extreme values affecting visualization selected_data1$log2FoldChange[selected_data1$log2FoldChange &gt; 5] &lt;- 5 # Set a minimum threshold for adjusted p-values to avoid extremely small values selected_data1$padj[selected_data1$padj &lt; 1e-60] &lt;- 1e-60 degs &lt;- subset(selected_data1, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) # Generate the volcano plot volcano_plot1 &lt;- plotVolcano( data = selected_data1, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 60), title = &quot;MOLM13: shPINK1-1 vs. Scramble&quot; ) ## shRNA2 vs Scramble (control) deseq_output2 &lt;- read.table(&quot;../03.out/figure2/M13_sh2_control_out_with_normalized_mat.txt&quot;, header = T) selected_data2 &lt;- deseq_output2[, 1:9] selected_data2$log2FoldChange[selected_data2$log2FoldChange &gt; 5] &lt;- 5 selected_data2$log2FoldChange[selected_data2$log2FoldChange &lt; -5] &lt;- -5 selected_data2$padj[selected_data2$padj &lt; 1e-60] &lt;- 1e-60 degs &lt;- subset(selected_data2, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) volcano_plot2 &lt;- plotVolcano( data = selected_data2, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 60), title = &quot;MOLM13: shPINK1-2 vs. Scramble&quot; ) ## shRNA1-2 vs Scramble (control) deseq_output3 &lt;- read.table(&quot;../03.out/figure2/M13_sh12_control_out_with_normalized_mat.txt&quot;, header = T) selected_data3 &lt;- deseq_output3[, 1:9] selected_data3$log2FoldChange[selected_data3$log2FoldChange &gt; 5] &lt;- 5 selected_data3$log2FoldChange[selected_data3$log2FoldChange &lt; -5] &lt;- -5 selected_data3$padj[selected_data3$padj &lt; 1e-50] &lt;- 1e-50 degs &lt;- subset(selected_data3, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) volcano_plot3 &lt;- plotVolcano( data = selected_data3, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 50), title = &quot;MOLM13: shPINK1-1-2 vs. Scramble&quot; ) plots &lt;- volcano_plot1 | volcano_plot2 | volcano_plot3 print(plots) # ggsave(&quot;../03.out/figure2/MOLM13_shPINK1_volcano_plot.pdf&quot;, plot = plots, width = 17, height = 5) "],["valcano-plots-oa3.html", "3.11 Valcano plots (OA3)", " 3.11 Valcano plots (OA3) ## OA3 ## shRNA1 vs Scramble (control) # gsym Pathway # Gene1 KEGG_RIBOSOME # Gene2 KEGG_DNA_REPLICATION custom_colors &lt;- brewer.pal(4, &quot;PiYG&quot;) # PiYG BrBG palette deseq_output1 &lt;- read.table(&quot;../03.out/figure2/OA3_sh1_control_out_with_normalized_mat.txt&quot;, header = T) selected_data1 &lt;- deseq_output1[, 1:9] # Cap log2 fold changes at 5 to avoid extreme values affecting visualization selected_data1$log2FoldChange[selected_data1$log2FoldChange &gt; 5] &lt;- 5 # Set a minimum threshold for adjusted p-values to avoid extremely small values selected_data1$padj[selected_data1$padj &lt; 1e-30] &lt;- 1e-30 degs &lt;- subset(selected_data1, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) # Generate the volcano plot volcano_plot1 &lt;- plotVolcano( data = selected_data1, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 30), title = &quot;OA3: shPINK1-1 vs. Scramble&quot; ) ## shRNA2 vs Scramble (control) deseq_output2 &lt;- read.table(&quot;../03.out/figure2/OA3_sh4_control_out_with_normalized_mat.txt&quot;, header = T) selected_data2 &lt;- deseq_output2[, 1:9] selected_data2$log2FoldChange[selected_data2$log2FoldChange &gt; 5] &lt;- 5 selected_data2$log2FoldChange[selected_data2$log2FoldChange &lt; -5] &lt;- -5 selected_data2$padj[selected_data2$padj &lt; 1e-60] &lt;- 1e-60 degs &lt;- subset(selected_data2, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) volcano_plot2 &lt;- plotVolcano( data = selected_data2, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 60), title = &quot;MOLM13: shPINK1-2 vs. Scramble&quot; ) ## shRNA1-2 vs Scramble (control) deseq_output3 &lt;- read.table(&quot;../03.out/figure2/M13_sh12_control_out_with_normalized_mat.txt&quot;, header = T) selected_data3 &lt;- deseq_output3[, 1:9] selected_data3$log2FoldChange[selected_data3$log2FoldChange &gt; 5] &lt;- 5 selected_data3$log2FoldChange[selected_data3$log2FoldChange &lt; -5] &lt;- -5 selected_data3$padj[selected_data3$padj &lt; 1e-40] &lt;- 1e-40 degs &lt;- subset(selected_data3, padj &lt; 0.05) overlap_genes &lt;- intersect(resis_sen$gsym, degs$Symbol) selected_genes &lt;- subset(resis_sen, gsym %in% overlap_genes) volcano_plot3 &lt;- plotVolcano( data = selected_data3, gene.col = &quot;Symbol&quot;, logFC.col = &quot;log2FoldChange&quot;, pval.col = &quot;padj&quot;, selected_genes = selected_genes, logFCcut = 0.5, logFCcut2 = 1, logFCcut3 = 2, pvalCut = 0.05, pvalCut2 = 0.0001, pvalCut3 = 0.00001, threshold_colors = custom_colors, plot_mode = &quot;advanced&quot;, x_range = c(-5, 5), y_range = c(0, 40), title = &quot;MOLM13: shPINK1-1-2 vs. Scramble&quot; ) plots &lt;- volcano_plot1 | volcano_plot2 | volcano_plot3 print(plots) # ggsave(&quot;../03.out/figure2/OA3_shPINK1_volcano_plot.pdf&quot;, plot = plots, width = 17, height = 5) "],["gsea-analysis-molm13.html", "3.12 GSEA analysis (MOLM13)", " 3.12 GSEA analysis (MOLM13) library(ggplot2) library(clusterProfiler) library(enrichplot) library(tidyverse) library(dplyr) library(GseaVis) # MOLM13 sh1 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/M13_sh1_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) # MOLM13 sh2 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/M13_sh2_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result out &lt;- gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) print(out) # MOLM13 sh1 and sh2 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/M13_sh12_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result out &lt;- gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) print(out) "],["gsea-analysis-oa3.html", "3.13 GSEA analysis (OA3)", " 3.13 GSEA analysis (OA3) library(ggplot2) library(clusterProfiler) library(enrichplot) library(tidyverse) library(dplyr) library(GseaVis) # OA3 sh1 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/OA3_sh1_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result p1 &lt;- gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) print(p1) # OA3 sh2 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/OA3_sh4_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result p2 &lt;- gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) print(p2) # OA3 sh1 and sh2 DEgene_mat &lt;- read.table(&quot;../03.out/figure2/OA3_sh14_control_out_with_normalized_mat.txt&quot;, header = T) DE_list &lt;- DEgene_mat[,c(9,3)] colnames(DE_list) &lt;- c(&quot;ID&quot;,&quot;Corr&quot;) DE_list &lt;- dplyr::distinct(DE_list, ID, .keep_all=TRUE) DE_list &lt;- na.omit(DE_list) DE_list &lt;- DE_list %&gt;% mutate(rank = rank(Corr, ties.method = &quot;random&quot;)) geneList &lt;- DE_list$Corr names(geneList)=DE_list$ID geneList &lt;- sort(geneList,decreasing = T) geneSet &lt;- read.gmt(&quot;../03.out/figure2/AZA_VEN_responsive_genes.gmt&quot;) set.seed(123456) gsea.enrich &lt;- GSEA(geneList,TERM2GENE = geneSet, pvalueCutoff = 1, nPermSimple = 1000, maxGSSize = 800, pAdjustMethod = &quot;BH&quot;, seed = TRUE) gsea.out &lt;- gsea.enrich@result p3 &lt;- gseaNb(object = gsea.enrich, geneSetID = c(&quot;Resistant_genes&quot;,&quot;Sensitive_genes&quot;), addPval = T, subPlot = 2, curveCol= c(&#39;#7582c1&#39;, &#39;#f99f1c&#39;), htCol= c( &quot;#7582c1&quot;, &quot;#f99f1c&quot;), rankCol= c( &quot;#7582c1&quot;, &quot;white&quot;, &quot;#f99f1c&quot;)) print(p3) ##################################### ## Dot plot for GO enrichment ## ##################################### library(ggplot2) gsea.out &lt;- read.csv(&quot;../03.out/figure2/gsea_dotplots.csv&quot;, header = T) gsea.out$Ajusted.Pvalue &lt;- ifelse(gsea.out$Ajusted.Pvalue == &quot;&lt;0.001&quot;, 0.001, gsea.out$Ajusted.Pvalue) gsea.out$Ajusted.Pvalue &lt;- as.numeric(gsea.out$Ajusted.Pvalue) gsea.out$negLog10P.adj &lt;- -log10(gsea.out$Ajusted.Pvalue) gsea.out$p_label &lt;- ifelse(gsea.out$Ajusted.Pvalue &lt; 0.05, &quot;*&quot;, NA) gsea.out$p_color &lt;- ifelse(gsea.out$Ajusted.Pvalue &lt; 0.05 &amp; gsea.out$NES &gt; 0, &quot;#40004B&quot;, ifelse(gsea.out$P.value &lt; 0.05 &amp; gsea.out$NES &lt; 0, &quot;#1B7837&quot;, NA)) # gsea.out$geneset &lt;- factor(gsea.out$geneset, levels = c(&quot;Sensitive&quot;, &quot;Resistant&quot;)) gsea.out$sh &lt;- factor(gsea.out$sh, levels = rev(c(&quot;shPINK1-1&quot;, &quot;shPINK1-2&quot;, &quot;shPINK1-1-2&quot;))) p &lt;- ggplot(gsea.out, aes(x=geneset, y=sh, fill=NES)) + theme_classic() + facet_grid(.~Cell_line) + geom_point(shape = 21, aes(size = 0.5), color=&quot;white&quot;) + geom_text(aes(label=p_label, color = p_color), size=5, vjust=0.76) + scale_fill_gradient2(low = &quot;#007575&quot;, high = &quot;#FFAA00&quot;, mid=&quot;#F7F7F7&quot;, midpoint=0) + scale_color_manual(values=c(&quot;#D3D3D3&quot;, &quot;#000000&quot;)) + theme( panel.grid = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), strip.text.y = element_text(angle = 0), strip.text.x = element_text(angle = 0), strip.background = element_blank(), panel.border = element_rect(color = &quot;black&quot;, fill = NA) ) + guides(size=&quot;none&quot;, color=&quot;none&quot;) + labs(x=&quot;&quot;, y=&quot;&quot;,fill=&quot;NES&quot;) print(p) "],["figure-3.html", "Chapter 4 Figure 3", " Chapter 4 Figure 3 Performance evaluation of the Random Forest (RF8) model for predicting venetoclax-azacitidine response "],["benchmark-ml-methods-for-prediction.html", "4.1 Benchmark ML Methods for Prediction", " 4.1 Benchmark ML Methods for Prediction library(mlr3) library(mlr3learners) library(mlr3verse) library(mlr3tuning) library(mlr3measures) library(data.table) library(mlr3benchmark) library(Boruta) library(caret) library(randomForest) library(pROC) library(PRROC) library(readxl) # Set seed for reproducibility set.seed(123456) # # ################################################ # ## Load Dataset and Prepare Classification Task # ################################################ # # Read gene expression data # data &lt;- readxl::read_excel(&quot;../02.data/TrainingTest_RJAML_Cohort1_84_genes.xlsx&quot;) # data &lt;- data[, -1] # Remove the first column if unnecessary (PatientID column) # data$Response &lt;- as.factor(data$Response) # Convert &#39;Response&#39; to factor for classification # # # Create classification task for mlr3 # task &lt;- TaskClassif$new(id = &quot;AML&quot;, backend = data, target = &quot;Response&quot;) # # ################################################ # ## Define Learners (Models) and Resampling Strategy # ################################################ # # Define a list of learners (classification models) # learners &lt;- list( # lrn(&quot;classif.rpart&quot;, predict_type = &quot;prob&quot;), # Decision Tree # lrn(&quot;classif.ranger&quot;, predict_type = &quot;prob&quot;), # Random Forest # lrn(&quot;classif.xgboost&quot;, predict_type = &quot;prob&quot;), # XGBoost # lrn(&quot;classif.log_reg&quot;, predict_type = &quot;prob&quot;), # Logistic Regression # lrn(&quot;classif.svm&quot;, predict_type = &quot;prob&quot;), # Support Vector Machine # lrn(&quot;classif.nnet&quot;, predict_type = &quot;prob&quot;), # Neural Network # lrn(&quot;classif.kknn&quot;, predict_type = &quot;prob&quot;), # K-Nearest Neighbors # lrn(&quot;classif.naive_bayes&quot;, predict_type = &quot;prob&quot;), # Naive Bayes # lrn(&quot;classif.glmnet&quot;, predict_type = &quot;prob&quot;), # ElasticNet # lrn(&quot;classif.cv_glmnet&quot;, predict_type = &quot;prob&quot;) # Cross-validated ElasticNet # ) # # # Define a 5-fold cross-validation resampling strategy repeated 100 times # resampling_repeated &lt;- rsmp(&quot;repeated_cv&quot;, folds = 5, repeats = 100) # # ################################################ # ## Benchmarking Setup and Execution # ################################################ # # Create benchmarking design grid # design &lt;- benchmark_grid( # tasks = task, # learners = learners, # resamplings = resampling_repeated # ) # # # Execute benchmark # bmr &lt;- benchmark(design) # # # Define performance measures # measures &lt;- list(msr(&quot;classif.auc&quot;), msr(&quot;classif.acc&quot;)) # # # Aggregate performance results # mean_score &lt;- bmr$aggregate(measures) # # # Extract benchmark scores for each iteration # score &lt;- bmr$score(measures) # score &lt;- score[, c(&quot;learner_id&quot;, &quot;iteration&quot;, &quot;classif.auc&quot;, &quot;classif.acc&quot;)] # # # Calculate mean and median AUC # mean_auc &lt;- mean(score$classif.auc, na.rm = TRUE) # median_auc &lt;- median(score$classif.auc, na.rm = TRUE) # Save benchmark results to a CSV file # write.csv(score, &quot;../03.out/figure3/ML_Results_GeneExp.csv&quot;) ################################################ ## Boruta Feature Selection ################################################ # Reload dataset and prepare for feature selection # data &lt;- read_excel(&quot;../02.data/TrainingTest_RJAML_Cohort1_84_genes.xlsx&quot;) # data &lt;- data[, -1] # Remove the first column if unnecessary # data$Response &lt;- as.factor(data$Response) # Convert &#39;Response&#39; to factor # # # Perform Boruta feature selection # set.seed(123) # boruta_result &lt;- Boruta(Response ~ ., data = data, pValue = 0.01, maxRuns = 1000, doTrace = 2) # boruta_selected &lt;- TentativeRoughFix(boruta_result) # # # Extract selected features (excluding tentative features) # selected_features &lt;- getSelectedAttributes(boruta_selected, withTentative = FALSE) # selected_features ####################################################### ## Train a Random Forest Model with Selected Features ####################################################### # Reload dataset and prepare with selected features # data &lt;- read_excel(&quot;../02.data/TrainingTest_RJAML_Cohort1_84_genes.xlsx&quot;) # data &lt;- data[, -1] # Remove PatientID column # data_selected &lt;- data[, c(&quot;Response&quot;, selected_features)] # Select important features # # # Log-transform feature values (excluding the Response column) # data_selected[, -1] &lt;- log2(data_selected[, -1] + 1) # data_selected$Response &lt;- as.factor(data_selected$Response) # Ensure &#39;Response&#39; is a factor # # # Split the dataset: 70% for training, 30% for testing # set.seed(12345) # trainIndex &lt;- createDataPartition(data_selected$Response, p = 0.7, list = FALSE) # trainData &lt;- data_selected[trainIndex, ] # testData &lt;- data_selected[-trainIndex, ] # # # Define training control with 5-fold cross-validation repeated 50 times # control &lt;- trainControl(method = &quot;repeatedcv&quot;, number = 5, repeats = 50, # classProbs = TRUE, summaryFunction = twoClassSummary) # # # Define hyperparameter tuning grid # tuneGrid &lt;- expand.grid(.mtry = c(1, 3, 5)) # # # Train a Random Forest model with hyperparameter tuning # rf_tuned &lt;- train( # Response ~ ., # data = trainData, # method = &quot;rf&quot;, # trControl = control, # tuneGrid = tuneGrid, # ntree = 50, # Number of trees # metric = &quot;ROC&quot; # Use ROC as the evaluation metric # ) # # # Save the trained Random Forest model to an RDS file # saveRDS(rf_tuned, file = &quot;../03.out/figure3/AZA_VEN_RandomForest8.rds&quot;) # Extract variable importance from the model # importance &lt;- varImp(rf_tuned, scale = FALSE) # # # Convert importance to a data frame for easier visualization # importance_df &lt;- data.frame( # Feature = rownames(importance$importance), # Importance = importance$importance$Overall # ) # # # Sort features by importance # importance_df &lt;- importance_df[order(importance_df$Importance, decreasing = TRUE), ] # Save feature importance to a CSV file # write.csv(importance_df, &quot;../03.out/figure3/RF_FeatureImportance.csv&quot;) "],["predict-class-labels-on-the-test-set-and-plot-roc.html", "4.2 Predict Class Labels on the Test Set and Plot ROC", " 4.2 Predict Class Labels on the Test Set and Plot ROC ######################################################### ## Predict Class Labels on the Test Set and Plot ROC ######################################################### library(pROC) library(PRROC) rf_tuned &lt;- readRDS(&quot;../03.out/figure3/AZA_VEN_RandomForest8.rds&quot;) data &lt;- read_excel(&quot;../02.data/TrainingTest_RJAML_Cohort1_84_genes.xlsx&quot;) data &lt;- data[, -1] data$Response &lt;- as.factor(data$Response) set.seed(12345) trainIndex &lt;- createDataPartition(data$Response, p = 0.7, list = FALSE) trainData &lt;- data[trainIndex, ] testData &lt;- data[-trainIndex, ] # Predict class labels and probabilities on the test set test_predictions &lt;- predict(rf_tuned, newdata = testData) test_probabilities &lt;- predict(rf_tuned, newdata = testData, type = &quot;prob&quot;) # Generate confusion matrix confusionMatrix(test_predictions, testData$Response) ## Confusion Matrix and Statistics ## ## Reference ## Prediction CR NonCR ## CR 3 1 ## NonCR 20 8 ## ## Accuracy : 0.3438 ## 95% CI : (0.1857, 0.5319) ## No Information Rate : 0.7188 ## P-Value [Acc &gt; NIR] : 1 ## ## Kappa : 0.0118 ## ## Mcnemar&#39;s Test P-Value : 8.568e-05 ## ## Sensitivity : 0.13043 ## Specificity : 0.88889 ## Pos Pred Value : 0.75000 ## Neg Pred Value : 0.28571 ## Prevalence : 0.71875 ## Detection Rate : 0.09375 ## Detection Prevalence : 0.12500 ## Balanced Accuracy : 0.50966 ## ## &#39;Positive&#39; Class : CR ## # Add predicted probabilities for CR testData$RF8.prob.CR &lt;- test_probabilities[, &quot;CR&quot;] # write.csv(testData, &quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;) testData &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = T) # Plot ROC curve for the test set roc_obj &lt;- roc(testData$Response, testData$RF8.prob.CR) # Save ROC plot to PDF p1 &lt;- plot(smooth(roc_obj), legacy.axes = TRUE, lwd = 2, main = &quot;Test set (N = 32)&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p1) ## ## Call: ## smooth.roc(roc = roc_obj) ## ## Data: testData$RF8.prob.CR in 23 controls (testData$Response CR) &gt; 9 cases (testData$Response NonCR). ## Smoothing: binormal ## Area under the curve: 0.8475 # Compute Precision-Recall curve and AUPRC for the test set testData$Response &lt;- factor(testData$Response, levels = c(&quot;NonCR&quot;, &quot;CR&quot;)) response_binary &lt;- as.numeric(testData$Response) - 1 pr_curve &lt;- pr.curve(scores.class0 = testData$RF8.prob.CR, weights.class0 = response_binary, curve = TRUE) p2 &lt;- plot(pr_curve, main = &quot;Test set (N = 32)&quot;, color = &quot;#1f77b4&quot;, auc.main = FALSE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUPRC =&quot;, round(pr_curve$auc.integral, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p2) ## NULL # ######################################################### # ## Predict Class Labels on the Training Set and Plot ROC # ######################################################### # # # Predict class labels and probabilities on the training set # train_predictions &lt;- predict(rf_tuned, newdata = trainData) # train_probabilities &lt;- predict(rf_tuned, newdata = trainData, type = &quot;prob&quot;) # # # Generate confusion matrix # confusionMatrix(train_predictions, trainData$Response) # # # Add predicted probabilities for CR # trainData$RF8.prob.CR &lt;- train_probabilities[, &quot;CR&quot;] # # # Plot ROC curve for the training set # roc_obj_train &lt;- roc(trainData$Response, trainData$RF8.prob.CR) # roc_obj_train$auc # # # Save ROC plot to PDF # pdf(&quot;figure3/RF8_Training_ROC.pdf&quot;, width = 4.2, height = 4) # plot(roc_obj_train, legacy.axes = TRUE, lwd = 2, # main = &quot;Training set (N = 78)&quot;, # xlab = &quot;False Positive Rate (1 - Specificity)&quot;, # ylab = &quot;True Positive Rate (Sensitivity)&quot;, # cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) # abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) # legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj_train$auc, 2))), # col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) # dev.off() ######################################################### ## Predict Class Labels on the Entire Dataset and Plot ROC ######################################################### # # Predict class labels and probabilities on the entire set # entire_predictions &lt;- predict(rf_tuned, newdata = data_selected) # entire_probabilities &lt;- predict(rf_tuned, newdata = data_selected, type = &quot;prob&quot;) # # # Generate confusion matrix # confusionMatrix(entire_predictions, data_selected$Response) # # # Add predicted probabilities and class labels # data_selected$RF8.prob.CR &lt;- entire_probabilities[, &quot;CR&quot;] # data_selected$Predicted_Response &lt;- entire_predictions # write.csv(data_selected, &quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;) # Plot ROC curve for the entire dataset data_selected &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = T) roc_obj_entire &lt;- roc(data_selected$Response, data_selected$RF8.prob.CR) roc_obj_entire$auc ## Area under the curve: 0.976 # Save ROC plot to PDF p3 &lt;- plot(roc_obj_entire, legacy.axes = TRUE, lwd = 2, main = &quot;Entire set (N = 110)&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) print(p3) ## ## Call: ## roc.default(response = data_selected$Response, predictor = data_selected$RF8.prob.CR) ## ## Data: data_selected$RF8.prob.CR in 77 controls (data_selected$Response CR) &gt; 33 cases (data_selected$Response NonCR). ## Area under the curve: 0.976 p4 &lt;- plot(roc_obj_entire, print.thres = &quot;best&quot;, col = &quot;#1f77b4&quot;, print.thres.cex = 1.2, add = TRUE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj_entire$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p4) ## ## Call: ## roc.default(response = data_selected$Response, predictor = data_selected$RF8.prob.CR) ## ## Data: data_selected$RF8.prob.CR in 77 controls (data_selected$Response CR) &gt; 33 cases (data_selected$Response NonCR). ## Area under the curve: 0.976 # Compute Precision-Recall curve and AUPRC for the entire dataset data_selected$Response &lt;- factor(data_selected$Response, levels = c(&quot;NonCR&quot;, &quot;CR&quot;)) response_binary_entire &lt;- as.numeric(data_selected$Response) - 1 pr_curve_entire &lt;- pr.curve(scores.class0 = data_selected$RF8.prob.CR, weights.class0 = response_binary_entire, curve = TRUE) p5 &lt;- plot(pr_curve_entire, main = &quot;Entire set (N = 110)&quot;, color = &quot;#1f77b4&quot;, auc.main = FALSE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUPRC =&quot;, round(pr_curve_entire$auc.integral, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p5) ## NULL "],["auc-and-auprc-heatmap-for-the-entire-and-test-sets.html", "4.3 AUC and AUPRC Heatmap for the Entire and Test Sets", " 4.3 AUC and AUPRC Heatmap for the Entire and Test Sets library(ggplot2) library(reshape2) library(RColorBrewer) library(gridExtra) auc_auprc_entire &lt;- read.csv(&quot;../03.out/figure3/AUC_AUPRC_Entire.csv&quot;, header = T) auc_auprc_test &lt;- read.csv(&quot;../03.out/figure3/AUC_AUPRC_Test.csv&quot;, header = T) # Prepare data for plotting: AUC and AUPRC for both Entire and Test datasets auc_entire_data &lt;- auc_auprc_entire[, c(&quot;Feature&quot;, &quot;AUC&quot;)] auprc_entire_data &lt;- auc_auprc_entire[, c(&quot;Feature&quot;, &quot;AUPRC&quot;)] auc_test_data &lt;- auc_auprc_test[, c(&quot;Feature&quot;, &quot;AUC&quot;)] auprc_test_data &lt;- auc_auprc_test[, c(&quot;Feature&quot;, &quot;AUPRC&quot;)] # Melt the data for ggplot auc_entire_melt &lt;- melt(auc_entire_data, id.vars = &quot;Feature&quot;) auprc_entire_melt &lt;- melt(auprc_entire_data, id.vars = &quot;Feature&quot;) auc_test_melt &lt;- melt(auc_test_data, id.vars = &quot;Feature&quot;) auprc_test_melt &lt;- melt(auprc_test_data, id.vars = &quot;Feature&quot;) # Function to generate heatmaps plot_heatmap &lt;- function(data, title) { ggplot(data, aes(x = variable, y = Feature, fill = value)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = round(value, 2)), size = 4) + scale_fill_gradientn(colors = rev(brewer.pal(9, &quot;BrBG&quot;)), limits = c(0.2, 1)) + theme_minimal() + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) + ggtitle(title) } # Generate heatmaps for the Entire and Test datasets auc_entire_plot &lt;- plot_heatmap(auc_entire_melt, &quot;AUC (Entire)&quot;) auprc_entire_plot &lt;- plot_heatmap(auprc_entire_melt, &quot;AUPRC (Entire)&quot;) auc_test_plot &lt;- plot_heatmap(auc_test_melt, &quot;AUC (Test)&quot;) auprc_test_plot &lt;- plot_heatmap(auprc_test_melt, &quot;AUPRC (Test)&quot;) out &lt;- grid.arrange(auc_entire_plot, auprc_entire_plot, auc_test_plot, auprc_test_plot, ncol = 2) print(out) ## TableGrob (2 x 2) &quot;arrange&quot;: 4 grobs ## z cells name grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] ## 3 3 (2-2,1-1) arrange gtable[layout] ## 4 4 (2-2,2-2) arrange gtable[layout] "],["model-performance-plot.html", "4.4 Model Performance Plot", " 4.4 Model Performance Plot library(ggplot2) library(tidyverse) library(RColorBrewer) # Load the results data &lt;- read.csv(&quot;../03.out/figure3/ML_Results_GeneExp.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # Melt the data for ggplot melted_data &lt;- data %&gt;% pivot_longer(cols = c(classif.auc, classif.acc), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% mutate(learner_id = toupper(gsub(&quot;classif.&quot;, &quot;&quot;, learner_id)), metric = toupper(gsub(&quot;classif.&quot;, &quot;&quot;, metric))) # Filter out non-finite values melted_data &lt;- melted_data %&gt;% filter(is.finite(value)) # Get the median AUC for sorting median_auc &lt;- melted_data %&gt;% filter(metric == &quot;AUC&quot;) %&gt;% group_by(learner_id) %&gt;% summarise(median_value = mean(value, na.rm = TRUE)) %&gt;% arrange(desc(median_value)) %&gt;% pull(learner_id) # Update factor levels melted_data$learner_id &lt;- factor(melted_data$learner_id, levels = median_auc) melted_data$metric &lt;- factor(melted_data$metric, levels = c(&quot;AUC&quot;, &quot;ACC&quot;)) # Define color palette palette_colors &lt;- colorRampPalette(rev(brewer.pal(6, &quot;Blues&quot;)))(length(unique(melted_data$learner_id))) # Create boxplot p &lt;- ggplot(melted_data, aes(x = learner_id, y = value, fill = learner_id)) + geom_boxplot() + stat_summary(fun = mean, geom = &quot;text&quot;, aes(label = round(after_stat(y), 3)), vjust = -0.5, color = &quot;black&quot;, size = 3.5) + facet_wrap(.~metric, ncol = 1) + scale_fill_manual(values = palette_colors) + labs(title = &quot;&quot;, x = &quot;&quot;, y = &quot;Model Performance&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 1)) print(p) "],["feature-importance.html", "4.5 Feature importance", " 4.5 Feature importance # Load feature importance data dat &lt;- read.csv(&quot;../03.out/figure3/RF_FeatureImportance.csv&quot;, header = TRUE) # Create feature importance bar plot p1 &lt;- ggplot(dat, aes(x = reorder(Feature, Importance), y = Importance, fill = Importance)) + geom_bar(stat = &quot;identity&quot;, width = 0.7) + coord_flip() + labs(title = &quot;&quot;, x = &quot;&quot;, y = &quot;Feature Importance&quot;) + scale_fill_gradient(low = &quot;#C6DBEF&quot;, high = &quot;#2171B5&quot;) + theme_bw() print(p1) "],["heatmap-for-confusion-matrices-defaut-cutoff-0.html", "4.6 Heatmap for Confusion Matrices (defaut cutoff 0.5)", " 4.6 Heatmap for Confusion Matrices (defaut cutoff 0.5) data &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = TRUE, row.names = 1) data$Predicted_Response &lt;- ifelse(data$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) # Create confusion matrix for test set confusion_matrix &lt;- table(data$Response, data$Predicted_Response) fisher.test(confusion_matrix) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: confusion_matrix ## p-value = 0.03498 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.01738007 0.99335695 ## sample estimates: ## odds ratio ## 0.1498523 # Convert to data frame confusion_matrix_df &lt;- as.data.frame(confusion_matrix) colnames(confusion_matrix_df) &lt;- c(&quot;True_Response&quot;, &quot;Predicted_Response&quot;, &quot;Count&quot;) # Calculate percentages total_counts &lt;- rowSums(confusion_matrix) confusion_matrix_df$Percent &lt;- with(confusion_matrix_df, Count / total_counts[True_Response]) # Plot confusion matrix heatmap for the test set p2 &lt;- ggplot(confusion_matrix_df, aes(x = Predicted_Response, y = True_Response, fill = Percent)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = paste(Count, &quot;\\n(&quot;, sprintf(&quot;%.2f&quot;, Percent), &quot;)&quot;, sep = &quot;&quot;)), size = 4) + scale_fill_gradient(low = &quot;#F7FBFF&quot;, high = &quot;#2171B5&quot;, limits = c(0, 1)) + labs(title = &quot;Test Set&quot;, x = &quot;Predicted Response&quot;, y = &quot;True Response&quot;) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5)) # Load entire set data data &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) data$Predicted_Response &lt;- ifelse(data$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) # Create confusion matrix for entire set confusion_matrix &lt;- table(data$Response, data$Predicted_Response) fisher.test(confusion_matrix) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: confusion_matrix ## p-value &lt; 2.2e-16 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.001138781 0.035730035 ## sample estimates: ## odds ratio ## 0.007780402 # Convert to data frame confusion_matrix_df &lt;- as.data.frame(confusion_matrix) colnames(confusion_matrix_df) &lt;- c(&quot;True_Response&quot;, &quot;Predicted_Response&quot;, &quot;Count&quot;) # Calculate percentages total_counts &lt;- rowSums(confusion_matrix) confusion_matrix_df$Percent &lt;- with(confusion_matrix_df, Count / total_counts[True_Response]) # Plot confusion matrix heatmap for the entire set p3 &lt;- ggplot(confusion_matrix_df, aes(x = Predicted_Response, y = True_Response, fill = Percent)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = paste(Count, &quot;\\n(&quot;, sprintf(&quot;%.2f&quot;, Percent), &quot;)&quot;, sep = &quot;&quot;)), size = 4) + scale_fill_gradient(low = &quot;#F7FBFF&quot;, high = &quot;#2171B5&quot;, limits = c(0, 1)) + labs(title = &quot;Entire Set&quot;, x = &quot;Predicted Response&quot;, y = &quot;True Response&quot;) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5)) # Save plot print(p3) "],["barplot-for-predicted-response-0.html", "4.7 Barplot for predicted Response (0.5)", " 4.7 Barplot for predicted Response (0.5) library(ggstatsplot) library(ggplot2) library(patchwork) # Test set bar plot data_test &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = TRUE, row.names = 1) data_test$Predicted_Response &lt;- ifelse(data_test$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) p_test &lt;- ggbarstats(data = data_test, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Test Set&quot;) # Entire set bar plot data_entire &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) data_entire$Predicted_Response &lt;- ifelse(data_entire$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) p_entire &lt;- ggbarstats(data = data_entire, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Entire Set&quot;) # Combine plots combined_barplot &lt;- p_test | p_entire print(combined_barplot) "],["heatmap-for-confusion-matrices-optimal-cutoff-0.html", "4.8 Heatmap for Confusion Matrices (optimal cutoff 0.630)", " 4.8 Heatmap for Confusion Matrices (optimal cutoff 0.630) data &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = TRUE, row.names = 1) data$Predicted_Response &lt;- ifelse(data$RF8.prob.CR &gt; 0.630, &quot;Responder&quot;, &quot;Non-responder&quot;) # Create confusion matrix for test set confusion_matrix &lt;- table(data$Response, data$Predicted_Response) fisher.test(confusion_matrix) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: confusion_matrix ## p-value = 0.0008973 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.0007500268 0.4013667126 ## sample estimates: ## odds ratio ## 0.03979367 # Convert to data frame confusion_matrix_df &lt;- as.data.frame(confusion_matrix) colnames(confusion_matrix_df) &lt;- c(&quot;True_Response&quot;, &quot;Predicted_Response&quot;, &quot;Count&quot;) # Calculate percentages total_counts &lt;- rowSums(confusion_matrix) confusion_matrix_df$Percent &lt;- with(confusion_matrix_df, Count / total_counts[True_Response]) # Plot confusion matrix heatmap for the test set p2 &lt;- ggplot(confusion_matrix_df, aes(x = Predicted_Response, y = True_Response, fill = Percent)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = paste(Count, &quot;\\n(&quot;, sprintf(&quot;%.2f&quot;, Percent), &quot;)&quot;, sep = &quot;&quot;)), size = 4) + scale_fill_gradient(low = &quot;#F7FBFF&quot;, high = &quot;#2171B5&quot;, limits = c(0, 1)) + labs(title = &quot;Test Set&quot;, x = &quot;Predicted Response&quot;, y = &quot;True Response&quot;) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5)) # Load entire set data data &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) data$Predicted_Response &lt;- ifelse(data$RF8.prob.CR &gt; 0.630, &quot;Responder&quot;, &quot;Non-responder&quot;) # Create confusion matrix for entire set confusion_matrix &lt;- table(data$Response, data$Predicted_Response) fisher.test(confusion_matrix) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: confusion_matrix ## p-value &lt; 2.2e-16 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 6.162635e-05 2.017811e-02 ## sample estimates: ## odds ratio ## 0.002532485 # Convert to data frame confusion_matrix_df &lt;- as.data.frame(confusion_matrix) colnames(confusion_matrix_df) &lt;- c(&quot;True_Response&quot;, &quot;Predicted_Response&quot;, &quot;Count&quot;) # Calculate percentages total_counts &lt;- rowSums(confusion_matrix) confusion_matrix_df$Percent &lt;- with(confusion_matrix_df, Count / total_counts[True_Response]) # Plot confusion matrix heatmap for the entire set p3 &lt;- ggplot(confusion_matrix_df, aes(x = Predicted_Response, y = True_Response, fill = Percent)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = paste(Count, &quot;\\n(&quot;, sprintf(&quot;%.2f&quot;, Percent), &quot;)&quot;, sep = &quot;&quot;)), size = 4) + scale_fill_gradient(low = &quot;#F7FBFF&quot;, high = &quot;#2171B5&quot;, limits = c(0, 1)) + labs(title = &quot;Entire Set&quot;, x = &quot;Predicted Response&quot;, y = &quot;True Response&quot;) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5)) plots &lt;- p2 | p3 print(plots) # ggsave(plots, filename = &quot;../03.out/figure3/RF8_Confusion_Test_Entire_optimal.pdf&quot;, width = 8.5, height = 3.5) "],["barplot-for-predicted-response-0.html", "4.9 Barplot for predicted Response (0.630)", " 4.9 Barplot for predicted Response (0.630) library(ggstatsplot) library(ggplot2) library(patchwork) # Test set bar plot data_test &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = TRUE, row.names = 1) data_test$Predicted_Response &lt;- ifelse(data_test$RF8.prob.CR &gt; 0.630, &quot;Responder&quot;, &quot;Non-responder&quot;) p_test &lt;- ggbarstats(data = data_test, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Test Set&quot;) # Entire set bar plot data_entire &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) data_entire$Predicted_Response &lt;- ifelse(data_entire$RF8.prob.CR &gt; 0.630, &quot;Responder&quot;, &quot;Non-responder&quot;) p_entire &lt;- ggbarstats(data = data_entire, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Entire Set&quot;) # Combine plots combined_barplot &lt;- p_test | p_entire print(combined_barplot) # ggsave(combined_barplot, filename = &quot;../03.out/figure3/RF8_barplot_Test_Entire_optimal.pdf&quot;, width = 7, height = 4.5) "],["density-plot-for-response-probability.html", "4.10 Density Plot for Response Probability", " 4.10 Density Plot for Response Probability data &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) # Create density plot for response probability p &lt;- ggdensity(data, x = &quot;RF8.prob.CR&quot;, add = &quot;mean&quot;, rug = TRUE, color = &quot;Response&quot;, xlab = &quot;Response Probability (RF8)&quot;, ylab = &quot;Density&quot;, fill = &quot;Response&quot;, palette = &quot;npg&quot;) print(p) "],["violin-and-boxplots-for-response-probability-rf8.html", "4.11 Violin and Boxplots for Response Probability (RF8)", " 4.11 Violin and Boxplots for Response Probability (RF8) library(ggplot2) library(reshape2) library(ggpubr) library(patchwork) # Define a function to generate plots for each dataset generate_plot &lt;- function(file_path, dataset_label) { data &lt;- read.csv(file_path, header = TRUE, row.names = 1) data$dataset &lt;- dataset_label p &lt;- ggplot(data, aes(x = Response, y = RF8.prob.CR, fill = Response)) + geom_violin(trim = FALSE) + geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) + scale_fill_manual(values = c(&quot;#93C89A&quot;, &quot;#FFCC98&quot;)) + facet_wrap(.~ dataset) + labs(title = &quot;&quot;, x = &quot;True Response&quot;, y = &quot;Response probability (RF8)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) + stat_compare_means(aes(label = ..p.format..), comparisons = list(c(&quot;CR&quot;, &quot;NonCR&quot;))) return(p) } # Generate plots for each dataset p4 &lt;- generate_plot(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, &quot;Test set&quot;) p5 &lt;- generate_plot(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, &quot;Entire set&quot;) # Combine all plots into a single layout using patchwork plots &lt;- p4 | p5 print(plots) "],["barplot-for-response.html", "4.12 Barplot for Response", " 4.12 Barplot for Response library(ggstatsplot) library(ggplot2) library(patchwork) # Test set bar plot data_test &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_test.csv&quot;, header = TRUE, row.names = 1) data_test$Predicted_Response &lt;- ifelse(data_test$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) p_test &lt;- ggbarstats(data = data_test, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Test Set&quot;) # Entire set bar plot data_entire &lt;- read.csv(&quot;../03.out/figure3/RF8_RJAML_cohort1_entire.csv&quot;, header = TRUE, row.names = 1) data_entire$Predicted_Response &lt;- ifelse(data_entire$RF8.prob.CR &gt; 0.5, &quot;Responder&quot;, &quot;Non-responder&quot;) p_entire &lt;- ggbarstats(data = data_entire, x = Response, y = Predicted_Response) + theme_classic() + ggtitle(&quot;Entire Set&quot;) # Combine plots combined_barplot &lt;- p_test | p_entire print(combined_barplot) "],["rf8-for-mdr-status.html", "4.13 RF8 for MDR status", " 4.13 RF8 for MDR status library(ggplot2) library(reshape2) library(ggpubr) library(patchwork) library(pROC) library(PRROC) dat &lt;- read.csv(&quot;../03.out/figure3/RJAML1_MRD_RF8.csv&quot;, header = T) # Plot ROC curve for the test set roc_obj &lt;- roc(dat$MRD.within.2cycles, dat$RF8) # pdf(&quot;../03.out/figure3/RF8_MDR.pdf&quot;, width = 5, height = 5) plot(smooth(roc_obj), legacy.axes = TRUE, lwd = 2, main = &quot;RF8 for MDR status&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) # dev.off() p2 &lt;- ggplot(dat, aes(x = MRD.within.2cycles, y = RF8, fill = MRD.within.2cycles)) + geom_violin(trim = FALSE) + geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) + scale_fill_manual(values = c(&quot;#93C89A&quot;, &quot;#FFCC98&quot;)) + labs(title = &quot;&quot;, x = &quot;True Response&quot;, y = &quot;Response probability (RF8)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) + stat_compare_means(aes(label = ..p.format..), comparisons = list(c(&quot;pos&quot;, &quot;neg&quot;))) print(p2) ggsave(p2, filename = &quot;../03.out/figure3/rf8_mrd_violin.pdf&quot;, width = 3, height = 4) "],["figure-4.html", "Chapter 5 Figure 4", " Chapter 5 Figure 4 Validation of the RF8 model "],["validation-of-rf8-model-rjaml-cohort-2.html", "5.1 Validation of RF8 model (RJAML-Cohort 2)", " 5.1 Validation of RF8 model (RJAML-Cohort 2) # Load the trained model # rf_tuned &lt;- readRDS(&quot;../03.out/figure3/AZA_VEN_RandomForest8.rds&quot;) # # # Load the new data for Cohort 2 # newDat &lt;- read_xlsx(&quot;../02.data/rjaml_test_all.xlsx&quot;) # newDat &lt;- newDat[, -1] # Remove the first column (Patient ID) # # # Select features and log-transform # data_selected &lt;- newDat[, c(&quot;Response&quot;, selected_features)] # data_selected[, -1] &lt;- log2(data_selected[, -1] + 1) # # # Predict class labels and probabilities for Cohort 2 # new_predictions &lt;- predict(rf_tuned, newdata = data_selected) # new_probabilities &lt;- predict(rf_tuned, newdata = data_selected, type = &quot;prob&quot;) # # # Add predictions to the dataset # newDat$Predicted_Response &lt;- new_predictions # newDat$RF8.prob.CR &lt;- new_probabilities[, &quot;CR&quot;] # write.csv(newDat, &quot;../03.out/figure4/RF8_Cohort2.csv&quot;) # Compute and plot ROC for Cohort 2 newDat &lt;- read.csv(&quot;../03.out/figure4/RF8_Cohort2.csv&quot;, header = T) roc_obj &lt;- roc(newDat$Response, newDat$RF8.prob.CR) roc_obj$auc ## Area under the curve: 0.8341 p1 &lt;- plot(smooth(roc_obj), legacy.axes = TRUE, lwd = 2, main = &quot;Cohort 2 (N = 32)&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p1) ## ## Call: ## smooth.roc(roc = roc_obj) ## ## Data: newDat$RF8.prob.CR in 22 controls (newDat$Response CR) &gt; 10 cases (newDat$Response NonCR). ## Smoothing: binormal ## Area under the curve: 0.8209 # Compute and plot Precision-Recall (PR) curve for Cohort 2 newDat$Response &lt;- factor(newDat$Response, levels = c(&quot;NonCR&quot;, &quot;CR&quot;)) response_binary &lt;- as.numeric(newDat$Response) - 1 pr_curve &lt;- pr.curve(scores.class0 = newDat$RF8.prob.CR, weights.class0 = response_binary, curve = TRUE) p2 &lt;- plot(pr_curve, main = &quot;Cohort 2 (N = 32)&quot;, color = &quot;#1f77b4&quot;, auc.main = FALSE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUPRC =&quot;, round(pr_curve$auc.integral, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p2) ## NULL "],["validation-of-rf8-model-fpmtb.html", "5.2 Validation of RF8 model (FPMTB)", " 5.2 Validation of RF8 model (FPMTB) # newDat &lt;- read_xlsx(&quot;../02.data/Validation_Exvivo_FPMTB_84Genes_43R_55S.xlsx&quot;) # newDat &lt;- newDat[, -1] # Remove the first column (Patient ID) # # Select features and log-transform # data_selected &lt;- newDat[, c(&quot;Response&quot;, selected_features)] # data_selected[, -1] &lt;- log2(data_selected[, -1] + 1) # # # Predict class labels and probabilities for the FPMTB set # new_predictions &lt;- predict(rf_tuned, newdata = data_selected) # new_probabilities &lt;- predict(rf_tuned, newdata = data_selected, type = &quot;prob&quot;) # # # Add predictions to the dataset # newDat$Predicted_Response &lt;- new_predictions # newDat$RF8.prob.CR &lt;- new_probabilities[, &quot;CR&quot;] # write.csv(newDat, &quot;../03.out/figure4/RF8_FPMTB.csv&quot;) newDat &lt;- read.csv(&quot;../03.out/figure4/RF8_FPMTB.csv&quot;, header = T) roc_obj &lt;- roc(newDat$Response, newDat$RF8.prob.CR) roc_obj$auc ## Area under the curve: 0.7283 p3 &lt;- plot(smooth(roc_obj), legacy.axes = TRUE, lwd = 2, main = &quot;FPMTB set (N = 98)&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p3) ## ## Call: ## smooth.roc(roc = roc_obj) ## ## Data: newDat$RF8.prob.CR in 55 controls (newDat$Response CR) &gt; 43 cases (newDat$Response NonCR). ## Smoothing: binormal ## Area under the curve: 0.6799 # Compute and plot Precision-Recall (PR) curve for the FPMTB set newDat$Response &lt;- factor(newDat$Response, levels = c(&quot;NonCR&quot;, &quot;CR&quot;)) response_binary &lt;- as.numeric(newDat$Response) - 1 pr_curve &lt;- pr.curve(scores.class0 = newDat$RF8.prob.CR, weights.class0 = response_binary, curve = TRUE) p4 &lt;- plot(pr_curve, main = &quot;FPMTB set (N = 98)&quot;, color = &quot;#1f77b4&quot;, auc.main = FALSE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUPRC =&quot;, round(pr_curve$auc.integral, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p4) ## NULL "],["validation-of-rf8-model-beataml.html", "5.3 Validation of RF8 model (BeatAML)", " 5.3 Validation of RF8 model (BeatAML) # newDat &lt;- read_xlsx(&quot;../02.data/Validation_Exvivo_BeatAML_84Genes_170R_88S.xlsx&quot;) # newDat &lt;- newDat[, -1] # Remove the first column (Patient ID) # # Select features and log-transform # data_selected &lt;- newDat[, c(&quot;Response&quot;, selected_features)] # data_selected[, -1] &lt;- log2(data_selected[, -1] + 1) # # Predict class labels and probabilities for the BeatAML set # new_predictions &lt;- predict(rf_tuned, newdata = data_selected) # new_probabilities &lt;- predict(rf_tuned, newdata = data_selected, type = &quot;prob&quot;) # # Add predictions to the dataset # newDat$Predicted_Response &lt;- new_predictions # newDat$RF8.prob.CR &lt;- new_probabilities[, &quot;CR&quot;] # write.csv(newDat, &quot;../03.out/figure4/RF8_BeatAML.csv&quot;) newDat &lt;- read.csv(&quot;../03.out/figure4/RF8_BeatAML.csv&quot;, header = T) # Compute and plot ROC for the BeatAML set roc_obj &lt;- roc(newDat$Response, newDat$RF8.prob.CR) roc_obj$auc ## Area under the curve: 0.7618 p1 &lt;- plot(smooth(roc_obj), legacy.axes = TRUE, lwd = 2, main = &quot;BeatAML set (N = 258)&quot;, xlab = &quot;False Positive Rate (1 - Specificity)&quot;, ylab = &quot;True Positive Rate (Sensitivity)&quot;, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1.1) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUC =&quot;, round(roc_obj$auc, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p1) ## ## Call: ## smooth.roc(roc = roc_obj) ## ## Data: newDat$RF8.prob.CR in 88 controls (newDat$Response CR) &gt; 170 cases (newDat$Response NonCR). ## Smoothing: binormal ## Area under the curve: 0.7557 # Compute and plot Precision-Recall (PR) curve for the BeatAML set newDat$Response &lt;- factor(newDat$Response, levels = c(&quot;NonCR&quot;, &quot;CR&quot;)) response_binary &lt;- as.numeric(newDat$Response) - 1 pr_curve &lt;- pr.curve(scores.class0 = newDat$RF8.prob.CR, weights.class0 = response_binary, curve = TRUE) p2 &lt;- plot(pr_curve, main = &quot;BeatAML set (N = 258)&quot;, color = &quot;#1f77b4&quot;, auc.main = FALSE) abline(h = seq(0, 1, by = 0.1), v = seq(0, 1, by = 0.1), col = &quot;gray80&quot;, lty = 2) legend(&quot;bottomright&quot;, legend = c(paste(&quot;AUPRC =&quot;, round(pr_curve$auc.integral, 2))), col = &quot;#1f77b4&quot;, lwd = 2, bty = &quot;n&quot;, cex = 1.2) print(p2) ## NULL "],["violin-and-boxplots-for-response-probability-rf8-1.html", "5.4 Violin and Boxplots for Response Probability (RF8)", " 5.4 Violin and Boxplots for Response Probability (RF8) library(ggplot2) library(reshape2) library(ggpubr) library(patchwork) # Define a function to generate plots for each dataset generate_plot &lt;- function(file_path, dataset_label) { data &lt;- read.csv(file_path, header = TRUE, row.names = 1) data$dataset &lt;- dataset_label p &lt;- ggplot(data, aes(x = Response, y = RF8.prob.CR, fill = Response)) + geom_violin(trim = FALSE) + geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) + scale_fill_manual(values = c(&quot;#93C89A&quot;, &quot;#FFCC98&quot;)) + facet_wrap(.~ dataset) + labs(title = &quot;&quot;, x = &quot;True Response&quot;, y = &quot;Response probability (RF8)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) + stat_compare_means(aes(label = ..p.format..), comparisons = list(c(&quot;CR&quot;, &quot;NonCR&quot;))) return(p) } p6 &lt;- generate_plot(&quot;../03.out/figure4/RF8_Cohort2.csv&quot;, &quot;Cohort 2&quot;) p7 &lt;- generate_plot(&quot;../03.out/figure4/RF8_FPMTB.csv&quot;, &quot;FPMTB set&quot;) p8 &lt;- generate_plot(&quot;../03.out/figure4/RF8_BeatAML.csv&quot;, &quot;BeatAML set&quot;) plots &lt;- p6 | p7 | p8 print(plots) "],["rf8-score-among-clusters.html", "5.5 RF8 score among clusters", " 5.5 RF8 score among clusters library(ggplot2) library(reshape2) library(ggpubr) library(patchwork) dat1 &lt;- read.csv(&quot;../03.out/figure4/RF8_FPMTB.csv&quot;, header = T) p1 &lt;- ggplot(dat1, aes(x = factor(Cluster), y = RF8.prob.CR, fill = factor(Cluster))) + geom_violin(trim = FALSE, alpha = 0.5) + geom_boxplot(width = 0.25, alpha = 0.75, position = position_dodge(0.9), outlier.shape = NA) + labs(title = &quot;FPMTB&quot;, x = &quot;Cluster&quot;, y = &quot;Response probability (RF8)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) + stat_compare_means( comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method = &quot;wilcox.test&quot;, label = &quot;p.signif&quot; ) + scale_fill_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) print(p1) dat2 &lt;- read.csv(&quot;../03.out/figure4/RF8_BeatAML.csv&quot;, header = T) p2 &lt;- ggplot(dat2, aes(x = factor(Cluster), y = RF8.prob.CR, fill = factor(Cluster))) + geom_violin(trim = FALSE, alpha = 0.5) + geom_boxplot(width = 0.25, alpha = 0.75, position = position_dodge(0.9), outlier.shape = NA) + labs(title = &quot;BeatAML&quot;, x = &quot;Cluster&quot;, y = &quot;Response probability (RF8)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) + stat_compare_means( comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method = &quot;wilcox.test&quot;, label = &quot;p.signif&quot; ) + scale_fill_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) print(p2) ggsave(p1, filename = &quot;../03.out/figure4/RF8_FPMTB_clusters.pdf&quot;, width = 5, height = 3.6) ggsave(p2, filename = &quot;../03.out/figure4/RF8_BeatAML_clusters.pdf&quot;, width = 5, height = 3.6) "],["integration-of-ex-vivo-drug-response-in-beataml.html", "5.6 Integration of ex vivo drug-response in BeatAML", " 5.6 Integration of ex vivo drug-response in BeatAML # Obtain the clinically approved drugs for AML library(reshape2) library(ggridges) library(ggplot2) library(tidyr) library(tidyverse) library(ggpubr) library(patchwork) drug_auc &lt;- read.table(&quot;../02.data/01_BeatAML_Inhibitor_AUC_values_v4_dbgap.txt&quot;, header = T,sep = &quot;\\t&quot;, check.names = FALSE) drug_select &lt;- subset(drug_auc, inhibitor %in% c(&quot;Azacytidine&quot;, &quot;Venetoclax&quot;)) drug_select &lt;- drug_select[, c(&quot;Sample&quot;, &quot;inhibitor&quot;, &quot;auc&quot;)] dat &lt;- dcast(drug_select, Sample~inhibitor) colnames(dat) &lt;- c(&quot;Sample&quot;, &quot;Azacitidine&quot;, &quot;Venetoclax&quot; ) id &lt;- read.csv(&quot;../02.data/02_RNAseq_Sample_ids.csv&quot;, header = T, check.names = FALSE) dat &lt;- merge(dat, id, by = &quot;Sample&quot;) row.names(dat) &lt;- dat$Sample dat &lt;- subset(dat, dat$diseaseStageAtSpecimenCollection %in% c(&quot;Initial Diagnosis&quot;, &quot;Relapse&quot;)) dat &lt;- subset(dat, dat$rnaSeq == &quot;y&quot;) ### select samples having more than 2 drugs tested dat$NA_number &lt;- rowSums(is.na(dat[, 2:3])) dat &lt;- subset(dat, NA_number == 0) dat &lt;- dat[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;)] head(dat) ## Azacitidine Venetoclax ## BA2000 232.2588 149.98987 ## BA2011 252.8421 226.33988 ## BA2022 233.7814 63.02199 ## BA2031 226.9534 187.70608 ## BA2033 223.5220 240.06542 ## BA2035 174.0980 22.71534 "],["beataml-waves-1-4-heatmap-based-on-drug-profiling.html", "5.7 BeatAML Waves 1-4 heatmap based on drug profiling", " 5.7 BeatAML Waves 1-4 heatmap based on drug profiling library(pheatmap) core_mat &lt;- dat core_mat1 &lt;- as.matrix(t(core_mat)) core_mat1 &lt;- log2(core_mat1 + 1) # core_mat1 &lt;- core_mat1 - apply(core_mat1, 1, mean) # core_mat1[which(core_mat1 &lt; -2)] &lt;- -2 # core_mat1[which(core_mat1 &gt; 2)] &lt;- 2 bk &lt;- unique(c(seq(-2, 2, length=100))) out &lt;- pheatmap(core_mat1, breaks = bk, cutree_cols = 2, color = colorRampPalette(c(&quot;#8C510A&quot;, &quot;#F5F5F5&quot;, &quot;#01665E&quot;))(100), scale = &quot;row&quot;, border_color = &quot;black&quot;, angle_col = 90, show_rownames = TRUE, show_colnames = FALSE, clustering_method = &quot;ward.D&quot;, #annotation_colors = ann_colors, #annotation_col = annotation_col, cluster_cols = T, cluster_rows = T ) print(out) # Order of clustered samples clust_sample &lt;- colnames(core_mat1[,out$tree_col[[&quot;order&quot;]]]) clust_sample &lt;- data.frame(clust_sample) sample_cluster &lt;- data.frame(cutree(out$tree_col, k=3)) colnames(sample_cluster) &lt;- &quot;Cluster&quot; data &lt;- data.frame(core_mat) data &lt;- cbind(data, sample_cluster) data$group &lt;- ifelse(data$Cluster == 1, &quot;Resistant&quot;, &quot;Sensitive&quot;) table(data$group) ## ## Resistant Sensitive ## 170 88 # write.csv(data, &quot;../03.out/figure4/BeatAML_exVivo_Resistant_Sensitive_Raw.csv&quot;) sample_cluster$Lable &lt;- ifelse(data$Cluster == 1, &quot;Resistant&quot;, &quot;Sensitive&quot;) annotation_col = data.frame( Lable = factor(sample_cluster$Lable) ) rownames(annotation_col) = colnames(core_mat1) ann_colors = list( Lable = c(Sensitive = &quot;#7c9d97&quot;, Resistant = &quot;#e9b383&quot;) ) # pdf(&quot;../03.out/figure4/01.BeatAML_exVivo_drug_heatmap.pdf&quot;, width = 10, height = 2) out &lt;- pheatmap(core_mat1, breaks = bk, cutree_cols = 3, color = colorRampPalette(c(&quot;#8C510A&quot;, &quot;#F5F5F5&quot;, &quot;#01665E&quot;))(100), scale = &quot;row&quot;, border_color = &quot;black&quot;, angle_col = 90, show_rownames = TRUE, show_colnames = FALSE, clustering_method = &quot;ward.D&quot;, annotation_colors = ann_colors, annotation_col = annotation_col, cluster_cols = T, cluster_rows = T ) # dev.off() print(out) # Extract scaled values from the heatmap object # Create matrix and scale manually (same scaling as pheatmap uses) core_matrix &lt;- as.matrix(core_mat1) scale_rows &lt;- function(x) { m &lt;- apply(x, 1, mean, na.rm = TRUE) s &lt;- apply(x, 1, sd, na.rm = TRUE) return((x - m) / s) } scaled_matrix &lt;- scale_rows(core_matrix) # Get cluster assignments (k=3) cluster_assignments &lt;- data.frame(Cluster = cutree(out$tree_col, k = 3)) # Combine scaled values with cluster assignments result_data &lt;- cbind(t(scaled_matrix), cluster_assignments) # write.csv(result_data, &quot;../03.out/figure4/BeatAML_exVivo_Resistant_Sensitive_scaled_scores.csv&quot;) "],["boxplot-for-drug-sensitivitity-between-resistant-and-sensitive.html", "5.8 Boxplot for drug sensitivitity between resistant and sensitive", " 5.8 Boxplot for drug sensitivitity between resistant and sensitive library(ggplot2) library(ggpubr) library(RColorBrewer) library(tidyverse) library(ggrastr) library(ggbeeswarm) mat &lt;- read.csv(&quot;../03.out/figure4/BeatAML_exVivo_Resistant_Sensitive_Raw.csv&quot;, header = T, row.names = 1) mat &lt;- mat[, c(&quot;group&quot;, &quot;Azacitidine&quot;, &quot;Venetoclax&quot;)] mat &lt;- mat %&gt;% gather(-&quot;group&quot;, key = &quot;drug&quot;, value = &quot;AUC&quot;) mat$drug &lt;- factor(mat$drug, levels = c(&quot;Azacitidine&quot;,&quot;Venetoclax&quot;)) p &lt;- ggplot(mat, aes(x = group, y = AUC, color = group)) + geom_boxplot_jitter() + geom_quasirandom(width=0.15, alpha = 0.75) + facet_wrap(.~drug, ncol=3) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Drug resistance (AUC)&quot;) + theme(strip.text.x = element_text(size=13)) + stat_compare_means(label = &quot;p.signif&quot;, comparisons = list(c(&#39;Resistant&#39;, &#39;Sensitive&#39;)), method=&#39;wilcox.test&#39;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;)) + theme(legend.position=&#39;None&#39;) print(p) ## Cluster (1 2 3) mat &lt;- read.csv(&quot;../03.out/figure4/BeatAML_exVivo_Resistant_Sensitive_Raw.csv&quot;, header = T, row.names = 1) mat &lt;- mat[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;, &quot;Cluster&quot;)] mat &lt;- mat %&gt;% gather(-&quot;Cluster&quot;, key = &quot;drug&quot;, value = &quot;sDSS&quot;) mat$Cluster &lt;- as.factor(mat$Cluster) p1 &lt;- ggplot(mat, aes(x = Cluster, y = sDSS, color = Cluster)) + geom_boxplot_jitter() + geom_quasirandom(width=0.15, alpha = 0.5) + facet_wrap(.~drug) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Drug resistance (AUC)&quot;) + theme(strip.text.x = element_text(size=13)) + stat_compare_means(comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method=&#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) + theme(legend.position=&#39;None&#39;) print(p1) ################################### ####### Scaled sensitivity scores ################################### # Clusters (1, 2, 3) drug_sensitivity_cluster &lt;- read.csv(&quot;../03.out/figure4/BeatAML_exVivo_Resistant_Sensitive_scaled_scores.csv&quot;, header = TRUE, row.names = 1) drug_sensitivity_cluster &lt;- drug_sensitivity_cluster[, c(&quot;Azacitidine&quot;, &quot;Venetoclax&quot;, &quot;Cluster&quot;)] drug_sensitivity_cluster &lt;- gather(drug_sensitivity_cluster, -Cluster, key = &quot;drug&quot;, value = &quot;sDSS&quot;) drug_sensitivity_cluster$Cluster &lt;- as.factor(drug_sensitivity_cluster$Cluster) p2 &lt;- ggplot(drug_sensitivity_cluster, aes(x = Cluster, y = sDSS, color = Cluster)) + geom_boxplot_jitter() + geom_quasirandom(width = 0.15, alpha = 0.5) + facet_wrap(~drug) + theme_pubr() + xlab(&quot;&quot;) + ylab(&quot;Scaled Drug sensitivity (sDSS)&quot;) + theme(strip.text.x = element_text(size = 13)) + stat_compare_means(comparisons = list(c(&#39;1&#39;, &#39;2&#39;), c(&#39;1&#39;, &#39;3&#39;), c(&#39;2&#39;, &#39;3&#39;)), method = &#39;wilcox.test&#39;, label = &quot;p.signif&quot;) + scale_color_manual(values = c(&quot;#e9b383&quot;, &quot;#7c9d97&quot;, &quot;#9cb0c3&quot;)) + theme(legend.position = &#39;None&#39;) print(p2) "],["figure-5.html", "Chapter 6 Figure 5", " Chapter 6 Figure 5 RF8 score correlates with genetic mutations in AML "],["integration-with-aml-genomics.html", "6.1 Integration with AML genomics", " 6.1 Integration with AML genomics library(tidyverse) library(ggpubr) library(ggsci) library(ggridges) library(cowplot) library(ggrastr) library(readxl) library(ggrastr) # Single mutation hcat &lt;- read_xlsx(&quot;../03.out/figure5/rjaml_mutations_rf8.xlsx&quot;) mut_variables &lt;- c(&quot;RF8.prob.CR&quot;, &quot;TP53&quot;, &quot;ASXL1&quot;, &quot;BCOR&quot;, &quot;BCORL1&quot;, &quot;CBL&quot;, &quot;CEBPA&quot;, &quot;ETV6&quot;, &quot;DDX41&quot;, &quot;DNMT3A&quot;, &quot;EZH2&quot;, &quot;FLT3-ITD&quot;, &quot;FLT3-TKD&quot;, &quot;IDH1&quot;, &quot;IDH2&quot;, &quot;KRAS&quot;, &quot;NF1&quot;,&quot;NPM1&quot;, &quot;NRAS&quot;, &quot;PHF6&quot;, &quot;PTPN11&quot;, &quot;RUNX1&quot;, &quot;SF3B1&quot;, &quot;SMC1A&quot;, &quot;SRSF2&quot;, &quot;STAG2&quot;, &quot;TET2&quot;, &quot;U2AF1&quot;, &quot;WT1&quot;, &quot;CBFB::MYH11&quot;, &quot;RUNX1::RUNX1T1&quot; ) hcat &lt;- hcat[, mut_variables] # Transform data for plotting alteration &lt;- hcat %&gt;% gather(-RF8.prob.CR, key=&#39;Alteration&#39;, value=&#39;Status&#39;) %&gt;% filter(Status &gt; 0) p1 &lt;- alteration %&gt;% ggplot(aes(y=fct_reorder(Alteration, RF8.prob.CR), x=RF8.prob.CR, fill=stat(x))) + geom_density_ridges_gradient( jittered_points = TRUE, scale=1.25, position=position_points_jitter(width=0.05, height=0), point_shape=&#39;|&#39;, point_size=3, point_alpha=0.3) + scale_fill_gradient2(low=&quot;grey&quot;, high=&quot;#9970AB&quot;, midpoint=0.5, name=&quot;&quot;) + theme_pubr() + ylab(&#39;&#39;) + xlab(&#39;RF8 score&#39;) + theme(legend.position=&#39;right&#39;, axis.title.x=element_text(size=15)) print(p1) "],["mutation-pairs.html", "6.2 Mutation pairs", " 6.2 Mutation pairs ## Obtain mutation pairs in AML patients library(dplyr) library(tidyr) library(readr) combos &lt;- read_xlsx(&quot;../03.out/figure5/mutations_pairs_rf8.xlsx&quot;) %&gt;% column_to_rownames(var = &quot;PatientID&quot;) # Select columns that contain &#39;mut&#39; and replace values df &lt;- combos %&gt;% select(contains(&quot;mut&quot;)) %&gt;% mutate(across(everything(), ~ replace_na(as.character(.), &quot;NA&quot;))) %&gt;% # mutate(across(everything(), ~ recode(., &quot;Positive&quot; = &quot;1&quot;, &quot;Negative&quot; = &quot;0&quot;, &quot;NA&quot; = &quot;0&quot;))) %&gt;% mutate(across(everything(), as.integer)) # Reorder by frequency and filter rows and columns df &lt;- df %&gt;% select(order(colSums(df), decreasing = TRUE)) %&gt;% filter(rowSums(.) &gt;= 2) %&gt;% select(where(~ sum(.) &gt; 1)) # Generate combinations of columns combinations &lt;- combn(colnames(df), 2) # Compute product of column pairs and bind them together df_comb &lt;- purrr::map_dfc(seq_len(ncol(combinations)), function(i) { combo &lt;- combinations[, i] col1 &lt;- df[[combo[1]]] col2 &lt;- df[[combo[2]]] setNames(as.data.frame(col1 * col2), paste(combo, collapse = &quot; + &quot;)) }) row.names(df_comb) &lt;- row.names(df) # Filter columns by frequency and reset index combo2 &lt;- df_comb %&gt;% select(where(~ sum(.) &gt; 1)) %&gt;% rownames_to_column(var = &quot;PatientID&quot;) # write_csv(combo2, &quot;../03.out/figure5/Two_mutations_combination_riskScore_final.csv&quot;, # col_names = TRUE) combo2 &lt;- combo2 %&gt;% gather(-PatientID, key=&#39;Mutation&#39;, value=&#39;Present&#39;) %&gt;% filter(Present &gt; 0) %&gt;% mutate(dnmt3a_dup = if_else((Mutation %&gt;% str_detect(&quot;DNMT3A \\\\(&quot;)) &amp; (Mutation %&gt;% str_detect(&quot;DNMT3A_mut&quot;)), &#39;TRUE&#39;, &#39;FALSE&#39;), flt3_dup = if_else((Mutation %&gt;% str_detect(&quot;FLT3 \\\\(&quot;)) &amp; (Mutation %&gt;% str_detect(&quot;FLT3_mut&quot;)), &#39;TRUE&#39;, &#39;FALSE&#39;)) %&gt;% filter((dnmt3a_dup == &#39;FALSE&#39;) &amp; (flt3_dup == &#39;FALSE&#39;)) %&gt;% select(-dnmt3a_dup, -flt3_dup) %&gt;% mutate(Mutation = Mutation %&gt;% str_replace_all(&#39;_mut&#39;, &#39;&#39;)) a &lt;- combo2 %&gt;% group_by(Mutation) %&gt;% summarise(Total = sum(Present)) %&gt;% ungroup() %&gt;% arrange(-Total) #%&gt;% head(50) a ## # A tibble: 175 × 2 ## Mutation Total ## &lt;chr&gt; &lt;int&gt; ## 1 FLT3 + FLT3-ITD 20 ## 2 DNMT3A + NPM1 16 ## 3 NPM1 + FLT3 15 ## 4 K/NRAS + NRAS 14 ## 5 DNMT3A + FLT3 13 ## 6 NPM1 + FLT3-ITD 13 ## 7 DNMT3A + IDH2 11 ## 8 DNMT3A + FLT3-ITD 10 ## 9 DNMT3A + TET2 9 ## 10 NPM1 + TET2 8 ## # ℹ 165 more rows # write_csv(a, &quot;../03.out/figure5/Two_mutations_combination_Freq_riskScore_final.csv&quot;) ## Plot mutation pairs dat &lt;- read.csv(&quot;../03.out/figure5/Two_mutations_combination_riskScore_final.csv&quot;, header = T, check.names = FALSE) # Initialize empty data frame for statistics stat &lt;- data.frame() # Calculate statistics for each mutation for (i in 3:ncol(dat)) { tmp &lt;- dat[, c(2, i)] colnames(tmp)[2] &lt;- &quot;Mutation&quot; tmp_0 &lt;- filter(tmp, Mutation == 0) tmp_1 &lt;- filter(tmp, Mutation == 1) testout &lt;- wilcox.test(tmp_0$RiskScore, tmp_1$RiskScore, alternative = &quot;two.sided&quot;) tmp_data &lt;- data.frame( Negative_median = median(tmp_0$RiskScore, na.rm = TRUE), Positive_median = median(tmp_1$RiskScore, na.rm = TRUE), P.value = testout$p.value, Mutation = colnames(dat)[i] ) stat &lt;- rbind(stat, tmp_data) } # Load frequency data and merge with statistics freq &lt;- read_csv(&quot;../03.out/figure5/Two_mutations_combination_Freq_riskScore_final.csv&quot;) stat &lt;- merge(stat, freq, by = &quot;Mutation&quot;) # write_csv(stat, &quot;../03.out/figure5/Two_mutations_Mut_vs.WT_stat.csv&quot;) # Plot two mutations plot &lt;- read_csv(&quot;../03.out/figure5/Two_mutations_Mut_vs.WT_stat.csv&quot;) %&gt;% filter(Total &gt;= 5) mutants &lt;- dat %&gt;% select(RiskScore, all_of(plot$Mutation)) alteration &lt;- mutants %&gt;% gather(key = &#39;Alteration&#39;, value = &#39;Status&#39;, -RiskScore) %&gt;% filter(Status &gt; 0) p9 &lt;- alteration %&gt;% ggplot(aes(y = fct_reorder(Alteration, RiskScore), x = RiskScore, fill = stat(x))) + geom_density_ridges_gradient( jittered_points = TRUE, scale = 1.25, position = position_points_jitter(width = 0.05, height = 0), point_shape = &#39;|&#39;, point_size = 3, point_alpha = 0.3 ) + scale_fill_gradient2(low = &quot;#01665E&quot;, high = &quot;#8C510A&quot;, midpoint = 0.5, name = &quot;&quot;) + theme_pubr() + ylab(&#39;&#39;) + xlab(&#39;Risk score&#39;) + theme( legend.position = &#39;right&#39;, axis.title.x = element_text(size = 15) ) print(p9) "],["complexheatmap-for-mutation.html", "6.3 Complexheatmap for mutation", " 6.3 Complexheatmap for mutation library(ComplexHeatmap) library(circlize) library(dplyr) library(readxl) library(RColorBrewer) data &lt;- read_xlsx(&quot;../03.out/figure5/rjaml_mutations_rf8.xlsx&quot;) # Define clinical and mutation variables clinic_variables &lt;- c(&quot;PatientID&quot;, &quot;Group&quot;, &quot;Age&quot;, &quot;BM_blast&quot;, &quot;Gender&quot;, &quot;Secondary_AML&quot;, &quot;Complex_Karyotype&quot;, &quot;ELN&quot;) mut_variables &lt;- c(&quot;PatientID&quot;, &quot;Group&quot;, &quot;TP53&quot;, &quot;ASXL1&quot;, &quot;BCOR&quot;, &quot;BCORL1&quot;, &quot;CBL&quot;, &quot;CEBPA&quot;, &quot;ETV6&quot;, &quot;DDX41&quot;, &quot;DNMT3A&quot;, &quot;EZH2&quot;, &quot;FLT3-ITD&quot;, &quot;FLT3-TKD&quot;, &quot;IDH1&quot;, &quot;IDH2&quot;, &quot;KRAS&quot;, &quot;NF1&quot;,&quot;NPM1&quot;, &quot;NRAS&quot;, &quot;PHF6&quot;, &quot;PTPN11&quot;, &quot;RUNX1&quot;, &quot;SF3B1&quot;, &quot;SMC1A&quot;, &quot;SRSF2&quot;, &quot;STAG2&quot;, &quot;TET2&quot;, &quot;U2AF1&quot;, &quot;WT1&quot;, &quot;CBFB::MYH11&quot;, &quot;RUNX1::RUNX1T1&quot; ) # Extract clinical and mutation data clinical_data &lt;- data[, clinic_variables] mutation_data &lt;- data[, mut_variables] # Set PatientID as row names and remove from both mutation and clinical data rownames(mutation_data) &lt;- mutation_data$PatientID mutation_data &lt;- mutation_data[, -1] # Remove PatientID column from mutation data rownames(clinical_data) &lt;- clinical_data$PatientID clinical_data &lt;- clinical_data[, -1] # Remove PatientID column from clinical data # Extract mutation matrix and transpose it mutation_matrix &lt;- mutation_data[, -1] # Remove Response column mutation_binary &lt;- apply(mutation_matrix, 2, function(x) ifelse(x == 1, &quot;Mutation&quot;, &quot;&quot;)) mutation_binary_transposed &lt;- t(mutation_binary) # Define custom colors for clinical variables col_age &lt;- colorRamp2(c(40, 80), c(&quot;#F7F7F7&quot;, &quot;#E69F00&quot;)) col_blast &lt;- colorRamp2(c(20, 100), c(&quot;#F7F7F7&quot;, &quot;#56B4E9&quot;)) clinical_annotation &lt;- HeatmapAnnotation( Group = clinical_data$Group, Age = clinical_data$Age, BM_blast = clinical_data$BM_blast, Gender = clinical_data$Gender, Secondary_AML = clinical_data$Secondary_AML, Complex_Karyotype = clinical_data$Complex_Karyotype, ELN = clinical_data$ELN, show_annotation_name = TRUE, col = list( Age = col_age, BM_blast = col_blast, Gender = c(&quot;0&quot; = &quot;#F0E442&quot;, &quot;1&quot; = &quot;#0072B2&quot;), Secondary_AML = c(&quot;0&quot; = &quot;#56B4E9&quot;, &quot;1&quot; = &quot;#E69F00&quot;), Complex_Karyotype = c(&quot;0&quot; = &quot;#999999&quot;, &quot;1&quot; = &quot;#D55E00&quot;), ELN = c(&quot;Favorable&quot; = &quot;#7c9d97&quot;, &quot;Intermediate&quot; = &quot;#9cb0c3&quot;, &quot;Adverse&quot; = &quot;#e9b383&quot;), Group = c(&quot;High&quot; = &quot;#7c9d97&quot;, &quot;Low&quot; = &quot;#e9b383&quot;) ) ) # Define alteration function alter_fun &lt;- list( background = function(x, y, w, h) { grid.rect(x, y, w - unit(0.5, &quot;mm&quot;), h - unit(1, &quot;mm&quot;), gp = gpar(fill = &#39;#ebebe1ff&#39;, col = NA)) }, Mutation = function(x, y, w, h) { grid.rect(x, y, w - unit(0.5, &quot;mm&quot;), h - unit(1, &quot;mm&quot;), gp = gpar(fill = &quot;#377EB8&quot;, col = NA)) # Mutation = Dark Blue } ) # Color function for mutation heatmap col &lt;- c(&quot;Mutation&quot; = &quot;#377EB8&quot;) # Generate oncoPrint heatmap # pdf(&quot;../03.out/figure5/03.oncoplot_map.pdf&quot;, width = 16, height = 9.5) out &lt;- oncoPrint( mutation_binary_transposed, alter_fun = alter_fun, col = col, column_split = clinical_data$Group, # Split columns by Response (CR/CRi vs Non-CR/CRi) bottom_annotation = clinical_annotation, # Add clinical annotations to the heatmap show_column_names = TRUE, show_row_names = TRUE, heatmap_legend_param = list(title = &quot;Alterations&quot;) ) # dev.off() print(out) "],["fisher-test.html", "6.4 Fisher test", " 6.4 Fisher test library(tidyverse) library(ggplot2) library(ggsci) library(scales) library(ggbreak) # Read input data fisher.dat &lt;- read_xlsx(&quot;../03.out/figure5/rjaml_mutations_rf8.xlsx&quot;) mut_variables &lt;- c(&quot;RF8.prob.CR&quot;, &quot;TP53&quot;, &quot;ASXL1&quot;, &quot;BCOR&quot;, &quot;BCORL1&quot;, &quot;CBL&quot;, &quot;CEBPA&quot;, &quot;ETV6&quot;, &quot;DDX41&quot;, &quot;DNMT3A&quot;, &quot;EZH2&quot;, &quot;FLT3-ITD&quot;, &quot;FLT3-TKD&quot;, &quot;IDH1&quot;, &quot;IDH2&quot;, &quot;KRAS&quot;, &quot;NF1&quot;,&quot;NPM1&quot;, &quot;NRAS&quot;, &quot;PHF6&quot;, &quot;PTPN11&quot;, &quot;RUNX1&quot;, &quot;SF3B1&quot;, &quot;SMC1A&quot;, &quot;SRSF2&quot;, &quot;STAG2&quot;, &quot;TET2&quot;, &quot;U2AF1&quot;, &quot;WT1&quot;, &quot;CBFB::MYH11&quot;, &quot;RUNX1::RUNX1T1&quot; ) fisher.dat &lt;- fisher.dat[, mut_variables] # Set options options(scipen = 100) # Initialize matrix to store Fisher test results stat1 &lt;- matrix(NA, nrow = ncol(fisher.dat) - 1, ncol = 4) # Perform Fisher test for each column (gene) for (i in 2:ncol(fisher.dat)) { m1 &lt;- fisher.dat[, c(1, i)] m1 &lt;- m1[complete.cases(m1), ] m1$RF8.prob.CR &lt;- ifelse(m1$RF8.prob.CR &gt;= median(m1$RF8.prob.CR), &quot;High&quot;, &quot;Low&quot;) # Create contingency table m2 &lt;- table(m1) m3 &lt;- matrix(c(m2[1], m2[2], m2[3], m2[4]), ncol = 2, nrow = 2) # Perform Fisher test s1 &lt;- fisher.test(m3) # Store results stat1[i - 1, ] &lt;- c(round(s1$p.value, 5), as.numeric(round(s1$estimate, 3)), round(s1$conf.int[1], 3), round(s1$conf.int[2], 3)) } # Convert results to data frame and add gene names stat1 &lt;- data.frame(stat1) stat1$Gene &lt;- colnames(fisher.dat)[2:ncol(fisher.dat)] colnames(stat1) &lt;- c(&quot;P.value&quot;, &quot;Odds_Ratio&quot;, &quot;Lower95%&quot;, &quot;Upper95%&quot;, &quot;Gene&quot;) # Reorder columns and sort by p-value stat &lt;- stat1[, c(&quot;Gene&quot;, &quot;P.value&quot;, &quot;Odds_Ratio&quot;, &quot;Lower95%&quot;, &quot;Upper95%&quot;)] stat &lt;- stat[order(stat$P.value), ] # write.csv(stat, &quot;../03.out/figure5/Mutation_fisher_out.csv&quot;) ################################### ###### dotplot Fisher test ###### ################################### # Read results data tab &lt;- read.csv(&quot;../03.out/figure5/Mutation_fisher_out.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # Subset data for significant results tab &lt;- subset(tab, P.value &lt; 0.05) tab &lt;- tab[order(tab$Odds_Ratio, decreasing = TRUE), ] # Order genes by odds ratio tab$Gene &lt;- factor(tab$Gene, levels = rev(tab$Gene)) # Create dot plot forest &lt;- ggplot(data = tab, aes(x = Odds_Ratio, y = Gene)) + geom_point(aes(color = -log2(P.value), size = 0.75), shape = 19) + geom_errorbarh(aes(xmin = `Lower95%`, xmax = `Upper95%`), height = 0, color = &quot;black&quot;) + geom_vline(xintercept = 1, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + theme_classic() + labs(x = &quot;Odds Ratio (OR)&quot;, y = &quot;&quot;) + theme( legend.position = &quot;right&quot;, legend.title = element_blank(), axis.text.x = element_text(angle = 0, hjust = 1, color = &quot;black&quot;), panel.grid.major = element_line(size = 0.1, linetype = &quot;dashed&quot;, color = &quot;grey&quot;), panel.grid.minor = element_line(size = 0.1, linetype = &quot;dashed&quot;, color = &quot;grey&quot;) ) # Customize plot color and scale p2 &lt;- forest + scale_color_gradient2(low = &quot;white&quot;, mid = &quot;white&quot;, high = &quot;#0072B5FF&quot;) + scale_x_log10() print(p2) "],["barplot-in-rjaml-cohort.html", "6.5 Barplot in RJAML cohort", " 6.5 Barplot in RJAML cohort library(ggstatsplot) library(patchwork) data &lt;- read_xlsx(&quot;../03.out/figure5/rjaml_mutations_rf8.xlsx&quot;) p1 &lt;- ggbarstats(data = data, x = TP53, y = Group) p2 &lt;- ggbarstats(data = data, x = DNMT3A, y = Group) p3 &lt;- ggbarstats(data = data, x = IDH2, y = Group) p4 &lt;- ggbarstats(data = data, x = CEBPA, y = Group) plots &lt;- p1|p2|p3|p4 print(plots) "],["table-one-for-multi-cohorts.html", "6.6 Table one for multi-cohorts", " 6.6 Table one for multi-cohorts #################################### ### Table one for multi-cohorts #################################### library(tableone) data &lt;- read.csv(&quot;../03.out/figure5/multi-cohorts_4gene_Clinicaldata.csv&quot;, header = T, check.names = FALSE) myVars &lt;- c(&quot;Age&quot;, &quot;Gender&quot;, &quot;Secondary_AML&quot;, &quot;Complex_Karyotype&quot;, &quot;FLT3-ITD&quot;, &quot;NPM1&quot;, &quot;KRAS&quot;, &quot;NRAS&quot;, &quot;CEBPA&quot;, &quot;DNMT3A&quot;, &quot;IDH2&quot;, &quot;TP53&quot;) catVars &lt;- c(&quot;Gender&quot;, &quot;Secondary_AML&quot;, &quot;Complex_Karyotype&quot;, &quot;FLT3-ITD&quot;, &quot;NPM1&quot;, &quot;KRAS&quot;, &quot;NRAS&quot;, &quot;CEBPA&quot;, &quot;DNMT3A&quot;, &quot;IDH2&quot;, &quot;TP53&quot;) tab &lt;- CreateTableOne(vars = myVars, strata = c(&quot;Response_group&quot;, &quot;Cohort&quot;), addOverall = TRUE, data = data, factorVars = catVars) tab2 &lt;- print(tab, showAllLevels = TRUE) ## Stratified by Response_group:Cohort ## level Overall CR/CRi:Daniel A. Pollyea_2018_NM ## n 427 29 ## Age (mean (SD)) 68.22 (9.76) 74.41 (5.60) ## Gender (%) Female 199 (46.6) 18 ( 62.1) ## Male 228 (53.4) 11 ( 37.9) ## Secondary_AML (%) No 295 (69.1) 19 ( 65.5) ## Yes 132 (30.9) 10 ( 34.5) ## Complex_Karyotype (%) 33 ( 7.7) 29 (100.0) ## No 308 (72.1) 0 ( 0.0) ## Yes 86 (20.1) 0 ( 0.0) ## FLT3-ITD (%) Mut 57 (13.3) 4 ( 13.8) ## WT 370 (86.7) 25 ( 86.2) ## NPM1 (%) Mut 92 (21.5) 8 ( 27.6) ## WT 335 (78.5) 21 ( 72.4) ## KRAS (%) 33 ( 7.7) 29 (100.0) ## Mut 19 ( 4.4) 0 ( 0.0) ## WT 375 (87.8) 0 ( 0.0) ## NRAS (%) Mut 40 ( 9.4) 1 ( 3.4) ## WT 387 (90.6) 28 ( 96.6) ## CEBPA (%) Mut 32 ( 7.5) 1 ( 3.4) ## WT 395 (92.5) 28 ( 96.6) ## DNMT3A (%) Mut 95 (22.2) 5 ( 17.2) ## WT 332 (77.8) 24 ( 82.8) ## IDH2 (%) Mut 70 (16.4) 5 ( 17.2) ## WT 357 (83.6) 24 ( 82.8) ## TP53 (%) Mut 57 (13.3) 2 ( 6.9) ## WT 370 (86.7) 27 ( 93.1) ## Stratified by Response_group:Cohort ## Non-response:Daniel A. Pollyea_2018_NM CR/CRi:DKFZ_Cohort1 ## n 4 40 ## Age (mean (SD)) 74.50 (7.05) 71.12 (8.35) ## Gender (%) 1 ( 25.0) 14 (35.0) ## 3 ( 75.0) 26 (65.0) ## Secondary_AML (%) 4 (100.0) 31 (77.5) ## 0 ( 0.0) 9 (22.5) ## Complex_Karyotype (%) 4 (100.0) 0 ( 0.0) ## 0 ( 0.0) 32 (80.0) ## 0 ( 0.0) 8 (20.0) ## FLT3-ITD (%) 1 ( 25.0) 5 (12.5) ## 3 ( 75.0) 35 (87.5) ## NPM1 (%) 0 ( 0.0) 10 (25.0) ## 4 (100.0) 30 (75.0) ## KRAS (%) 4 (100.0) 0 ( 0.0) ## 0 ( 0.0) 3 ( 7.5) ## 0 ( 0.0) 37 (92.5) ## NRAS (%) 0 ( 0.0) 4 (10.0) ## 4 (100.0) 36 (90.0) ## CEBPA (%) 0 ( 0.0) 2 ( 5.0) ## 4 (100.0) 38 (95.0) ## DNMT3A (%) 0 ( 0.0) 8 (20.0) ## 4 (100.0) 32 (80.0) ## IDH2 (%) 0 ( 0.0) 9 (22.5) ## 4 (100.0) 31 (77.5) ## TP53 (%) 1 ( 25.0) 3 ( 7.5) ## 3 ( 75.0) 37 (92.5) ## Stratified by Response_group:Cohort ## Non-response:DKFZ_Cohort1 CR/CRi:ECLA Non-response:ECLA ## n 14 42 23 ## Age (mean (SD)) 67.71 (7.31) 64.48 (11.08) 69.96 (10.17) ## Gender (%) 3 ( 21.4) 19 (45.2) 8 ( 34.8) ## 11 ( 78.6) 23 (54.8) 15 ( 65.2) ## Secondary_AML (%) 6 ( 42.9) 39 (92.9) 21 ( 91.3) ## 8 ( 57.1) 3 ( 7.1) 2 ( 8.7) ## Complex_Karyotype (%) 0 ( 0.0) 0 ( 0.0) 0 ( 0.0) ## 6 ( 42.9) 36 (85.7) 16 ( 69.6) ## 8 ( 57.1) 6 (14.3) 7 ( 30.4) ## FLT3-ITD (%) 1 ( 7.1) 3 ( 7.1) 2 ( 8.7) ## 13 ( 92.9) 39 (92.9) 21 ( 91.3) ## NPM1 (%) 1 ( 7.1) 6 (14.3) 0 ( 0.0) ## 13 ( 92.9) 36 (85.7) 23 (100.0) ## KRAS (%) 0 ( 0.0) 0 ( 0.0) 0 ( 0.0) ## 1 ( 7.1) 3 ( 7.1) 2 ( 8.7) ## 13 ( 92.9) 39 (92.9) 21 ( 91.3) ## NRAS (%) 1 ( 7.1) 5 (11.9) 2 ( 8.7) ## 13 ( 92.9) 37 (88.1) 21 ( 91.3) ## CEBPA (%) 0 ( 0.0) 5 (11.9) 4 ( 17.4) ## 14 (100.0) 37 (88.1) 19 ( 82.6) ## DNMT3A (%) 2 ( 14.3) 12 (28.6) 4 ( 17.4) ## 12 ( 85.7) 30 (71.4) 19 ( 82.6) ## IDH2 (%) 1 ( 7.1) 7 (16.7) 2 ( 8.7) ## 13 ( 92.9) 35 (83.3) 21 ( 91.3) ## TP53 (%) 4 ( 28.6) 8 (19.0) 6 ( 26.1) ## 10 ( 71.4) 34 (81.0) 17 ( 73.9) ## Stratified by Response_group:Cohort ## CR/CRi:PSS_CD Non-response:PSS_CD CR/CRi:RJAML ## n 85 15 119 ## Age (mean (SD)) 69.75 (13.14) 66.73 (10.90) 66.66 (7.00) ## Gender (%) 47 ( 55.3) 4 ( 26.7) 61 (51.3) ## 38 ( 44.7) 11 ( 73.3) 58 (48.7) ## Secondary_AML (%) 67 ( 78.8) 13 ( 86.7) 67 (56.3) ## 18 ( 21.2) 2 ( 13.3) 52 (43.7) ## Complex_Karyotype (%) 0 ( 0.0) 0 ( 0.0) 0 ( 0.0) ## 62 ( 72.9) 9 ( 60.0) 102 (85.7) ## 23 ( 27.1) 6 ( 40.0) 17 (14.3) ## FLT3-ITD (%) 15 ( 17.6) 2 ( 13.3) 19 (16.0) ## 70 ( 82.4) 13 ( 86.7) 100 (84.0) ## NPM1 (%) 27 ( 31.8) 2 ( 13.3) 32 (26.9) ## 58 ( 68.2) 13 ( 86.7) 87 (73.1) ## KRAS (%) 0 ( 0.0) 0 ( 0.0) 0 ( 0.0) ## 0 ( 0.0) 3 ( 20.0) 5 ( 4.2) ## 85 (100.0) 12 ( 80.0) 114 (95.8) ## NRAS (%) 5 ( 5.9) 3 ( 20.0) 13 (10.9) ## 80 ( 94.1) 12 ( 80.0) 106 (89.1) ## CEBPA (%) 5 ( 5.9) 0 ( 0.0) 12 (10.1) ## 80 ( 94.1) 15 (100.0) 107 (89.9) ## DNMT3A (%) 22 ( 25.9) 3 ( 20.0) 32 (26.9) ## 63 ( 74.1) 12 ( 80.0) 87 (73.1) ## IDH2 (%) 15 ( 17.6) 0 ( 0.0) 23 (19.3) ## 70 ( 82.4) 15 (100.0) 96 (80.7) ## TP53 (%) 8 ( 9.4) 2 ( 13.3) 11 ( 9.2) ## 77 ( 90.6) 13 ( 86.7) 108 (90.8) ## Stratified by Response_group:Cohort ## Non-response:RJAML p test ## n 56 ## Age (mean (SD)) 66.07 (8.38) &lt;0.001 ## Gender (%) 24 (42.9) 0.050 ## 32 (57.1) ## Secondary_AML (%) 28 (50.0) &lt;0.001 ## 28 (50.0) ## Complex_Karyotype (%) 0 ( 0.0) &lt;0.001 ## 45 (80.4) ## 11 (19.6) ## FLT3-ITD (%) 5 ( 8.9) 0.759 ## 51 (91.1) ## NPM1 (%) 6 (10.7) 0.006 ## 50 (89.3) ## KRAS (%) 0 ( 0.0) &lt;0.001 ## 2 ( 3.6) ## 54 (96.4) ## NRAS (%) 6 (10.7) 0.768 ## 50 (89.3) ## CEBPA (%) 3 ( 5.4) 0.352 ## 53 (94.6) ## DNMT3A (%) 7 (12.5) 0.462 ## 49 (87.5) ## IDH2 (%) 8 (14.3) 0.562 ## 48 (85.7) ## TP53 (%) 12 (21.4) 0.068 ## 44 (78.6) # write.csv(tab2, file = &quot;../03.out/figure5/multi-cohorts_4gene_Clinicaldata_out.csv&quot;) "],["barplot-for-real-response.html", "6.7 Barplot for real response", " 6.7 Barplot for real response library(ggstatsplot) library(patchwork) dat &lt;- read.csv(&quot;../03.out/figure5/multi-cohorts_4gene_data.csv&quot;, header = TRUE) p1 &lt;- ggbarstats(dat, y = TP53, x = Response_group, palette = &quot;Paired&quot;, label = &quot;counts&quot;) p2 &lt;- ggbarstats(dat, y = DNMT3A, x = Response_group, palette = &quot;Paired&quot;, label = &quot;counts&quot;) p3 &lt;- ggbarstats(dat, y = IDH2, x = Response_group, palette = &quot;Paired&quot;, label = &quot;counts&quot;) p4 &lt;- ggbarstats(dat, y = CEBPA, x = Response_group, palette = &quot;Paired&quot;, label = &quot;counts&quot;) plots &lt;- p1|p2|p3|p4 print(plots) "],["multivariable-logisticreg.html", "6.8 Multivariable LogisticReg", " 6.8 Multivariable LogisticReg library(forestmodel) library(ggplot2) library(ggsci) library(scales) library(ggbreak) #--------------------- # Load the Data #--------------------- dat &lt;- read_xlsx(&quot;../03.out/figure5/rjaml_mutations_rf8.xlsx&quot;) dat$Response &lt;- ifelse(dat$Response == &#39;NonCR&#39;, 1, 0) dat$ELN &lt;- ifelse(dat$ELN == &quot;Adverse&quot;, 1, 0) # Define forest plot panels forest.panels &lt;- list( list(width = 0.01), list(width = 0.1, display = ~variable, fontface = &quot;bold&quot;, heading = &quot;Variable&quot;), list(width = 0.1, display = ~level), list(width = 0.05, display = ~n, hjust = 1, heading = &quot;N&quot;), list(width = 0.03, item = &quot;vline&quot;, hjust = 0.5), list(width = 0.55, item = &quot;forest&quot;, hjust = 0.5, heading = &quot;Odds ratio&quot;, linetype = &quot;dashed&quot;, line_x = 0), list(width = 0.03, item = &quot;vline&quot;, hjust = 0.5), list(width = 0.12, display = ~ ifelse(reference, &quot;Reference&quot;, sprintf(&quot;%0.3f (%0.3f, %0.3f)&quot;, trans(estimate), trans(conf.low), trans(conf.high))), display_na = NA), list(width = 0.03, display = ~ ifelse(reference, &quot;&quot;, format.pval(p.value, digits = 1, eps = 0.001)), display_na = NA, hjust = 1, heading = &quot;p&quot;), list(width = 0.03) ) # Define function to create forest plots create_forest_plot &lt;- function(data) { formula &lt;- as.formula(paste0(&#39;Response ~ &#39;, paste(c(&#39;RF8.prob.CR&#39;, &#39;Age&#39;, &#39;Gender&#39;, &#39;BM_blast&#39;, &#39;Secondary_AML&#39;, &#39;Complex_Karyotype&#39;, &#39;ELN&#39;, &#39;TP53&#39;, &#39;IDH2&#39;, &#39;DNMT3A&#39;, &#39;CEBPA&#39;), collapse = &#39; + &#39;))) model &lt;- glm(formula, data = data, family = binomial) print(forest_model(model, panels = forest.panels, factor_separate_line = FALSE)) } out &lt;- create_forest_plot(dat) print(out) "],["identification-of-rf8-correlated-genes.html", "6.9 Identification of RF8-correlated genes", " 6.9 Identification of RF8-correlated genes # library(dplyr) # library(DESeq2) # source(&quot;RunDESeq2.R&quot;) # # # Load TPM and raw count data # tpm &lt;- read.table(&quot;../02.data/ID_matched_TPM_matrix.txt&quot;, header = TRUE, check.names = FALSE) # sample_info &lt;- read.csv(&quot;D:\\\\01.Projects\\\\01.project\\\\35_AZA_VEN\\\\00.RNAseq_Model\\\\figure3\\\\rjaml_rf8_scores.csv&quot;, header = TRUE, check.names = FALSE) # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # tpm &lt;- subset(tpm, Type %in% c(&quot;protein_coding&quot;, &quot;miRNA&quot;, &quot;lincRNA&quot;, &quot;antisense&quot;, # &quot;processed_transcript&quot;, # &quot;transcribed_processed_pseudogene&quot;, &quot;transcribed_unitary_pseudogene&quot;, # &quot;transcribed_unprocessed_pseudogene&quot;,&quot;macro_lncRNA&quot;, &quot;TEC&quot;, # &quot;3prime_overlapping_ncRNA&quot;,&quot;sense_intronic&quot;, &quot;sense_overlapping&quot;, # &quot;unprocessed_pseudogene&quot;)) # # tpm &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0.5), ] # tpm &lt;- tpm[!duplicated(tpm$Symbol), ] # row.names(tpm) &lt;- tpm$Symbol # tpm &lt;- tpm[, -c(1:3)] # tpm &lt;- data.frame(t(tpm)) # tpm &lt;- log2(tpm + 1) # # dat &lt;- cbind(sample_info$RF8, tpm) # colnames(dat)[1] &lt;- &quot;RF8&quot; # # ## Define a dataframe to store the results # # stat1 &lt;- data.frame(matrix(NA, nrow = (ncol(dat)-1), ncol = 3)) # stat1[, 1] &lt;- colnames(dat)[2:ncol(dat)] # # for (i in 2:ncol(dat)) { # res &lt;- cor.test(dat[,1], dat[,i], method = &quot;pearson&quot;) # stat1[i-1, 2] &lt;- res$p.value # stat1[i-1, 3] &lt;- res$estimate # } # # colnames(stat1) &lt;- c(&quot;ID&quot;, &quot;P.value&quot;, &quot;rho&quot;) # stat1$fdr &lt;- p.adjust(stat1$P.value, method =&quot;BH&quot;) # # write.csv(stat1, &quot;../03.out/figure5/RF8_correlatedGenes.csv&quot;) library(ggplot2) library(ggrepel) library(ggrastr) library(viridis) stat1 &lt;- read.csv(&quot;../03.out/figure5/RF8_correlatedGenes.csv&quot;, header = T) stat1$rank_score &lt;- -log2(stat1$P.value) * abs(stat1$rho) dat &lt;- stat1[order(stat1$rank_score, decreasing = TRUE), ] dat$Rank &lt;- 1:nrow(stat1) dat1 &lt;- head(dat, 20) # Sort data by rank_score and find the top 500 threshold top_1000_threshold &lt;- dat$rank_score[order(dat$rank_score, decreasing = TRUE)][1000] # Plotting p &lt;- ggplot(dat, aes(x = Rank, y = rank_score, color = rank_score)) + geom_point_rast(aes(size = abs(rank_score)), alpha = 0.8, raster.dpi = 350, stroke = 0) + scale_color_viridis(option = &quot;plasma&quot;, direction = -1, name = &quot;Rank Score&quot;) + labs(x = &quot;Rank&quot;, y = &quot;Rank score&quot;) + theme_classic(base_size = 14) + theme( legend.position = &quot;right&quot;, legend.title = element_text(size = 12, face = &quot;bold&quot;), legend.text = element_text(size = 10), panel.grid.major = element_line(size = 0.2, linetype = &quot;dashed&quot;, color = &quot;grey&quot;), panel.grid.minor = element_blank(), plot.title = element_text(size = 16, face = &quot;bold&quot;, hjust = 0.5) ) + geom_hline(yintercept = top_1000_threshold, color = &quot;red&quot;, linetype = &quot;dotted&quot;, lwd = 0.8) + annotate(&quot;text&quot;, x = max(dat$Rank) * 0.95, y = top_1000_threshold, label = paste0(&quot;Top 1000 Genes (&quot;, round(top_1000_threshold, 2), &quot;)&quot;), vjust = -0.5, hjust = 1, color = &quot;red&quot;, fontface = &quot;bold&quot;, size = 4) + scale_size_continuous(range = c(2, 6)) # Adjust point size range for better visibility # Adding highlighted points and labels p1 &lt;- p + geom_point(data = dat1, aes(size = abs(rank_score)), shape = 21, stroke = 1.5, color = &quot;black&quot;, fill = &quot;white&quot;) + geom_label_repel(data = dat1, aes(label = ID), color = &quot;black&quot;, box.padding = unit(0.4, &quot;lines&quot;), point.padding = unit(0.5, &quot;lines&quot;), max.overlaps = 100, segment.color = &quot;grey50&quot;, size = 4, fontface = &quot;bold&quot;, fill = &quot;lightyellow&quot;) print(p1) "],["differential-expression-analysis-for-mut-vs.-wt.html", "6.10 Differential Expression Analysis for Mut vs. WT", " 6.10 Differential Expression Analysis for Mut vs. WT ########################################################################## ### Differential Expression Analysis for Mut vs. WT ########################################################################## # # Filter data for relevant samples # source(&quot;RunDESeq2.R&quot;) # mat &lt;- read.table(&quot;../02.data/ID_matched_count_matrix.txt&quot;, header = T, row.names = 1) # mat &lt;- mat[, -c(1:2)] # tpm &lt;- read.table(&quot;../02.data/ID_matched_TPM_matrix.txt&quot;, header = TRUE, check.names = FALSE) # sample_info &lt;- read.csv(&quot;../02.data/rjaml_rf8_scores.csv&quot;, header = TRUE, check.names = FALSE) # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # tpm &lt;- subset(tpm, Type %in% c(&quot;protein_coding&quot;, &quot;miRNA&quot;, &quot;lincRNA&quot;, &quot;antisense&quot;, # &quot;processed_transcript&quot;, # &quot;transcribed_processed_pseudogene&quot;, &quot;transcribed_unitary_pseudogene&quot;, # &quot;transcribed_unprocessed_pseudogene&quot;,&quot;macro_lncRNA&quot;, &quot;TEC&quot;, # &quot;3prime_overlapping_ncRNA&quot;,&quot;sense_intronic&quot;, &quot;sense_overlapping&quot;, # &quot;unprocessed_pseudogene&quot;)) # # tpm &lt;- tpm[which(rowMeans(tpm[, -c(1:3)]) &gt; 0.5), ] # tpm &lt;- tpm[!duplicated(tpm$Symbol), ] # # ### TP53 Mutation vs. WT # sample_info &lt;- sample_info[order(sample_info$TP53), ] # table(sample_info$TP53) # # mat &lt;- mat[tpm$ID, sample_info$PatientID] # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat, n.cont = 100, n.treat = 10, # prefix = &quot;../03.out/figure5/DESeq2_out_TP53_Mut_WT&quot;, # sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) # # ### DNMT3A Mutation vs. WT # sample_info &lt;- sample_info[order(sample_info$DNMT3A), ] # table(sample_info$DNMT3A) # # mat &lt;- mat[tpm$ID, sample_info$PatientID] # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat, n.cont = 83, n.treat = 27, # prefix = &quot;../03.out/figure5/DESeq2_out_DNMT3A_Mut_WT&quot;, # sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) # # ### IDH2 Mutation vs. WT # sample_info &lt;- sample_info[order(sample_info$IDH2), ] # table(sample_info$IDH2) # # mat &lt;- mat[tpm$ID, sample_info$PatientID] # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat, n.cont = 84, n.treat = 26, # prefix = &quot;../03.out/figure5/DESeq2_out_IDH2_Mut_WT&quot;, # sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) # # ### CEBPA Mutation vs. WT # sample_info &lt;- sample_info[order(sample_info$CEBPA), ] # table(sample_info$CEBPA) # # mat &lt;- mat[tpm$ID, sample_info$PatientID] # tpm &lt;- tpm[, c(&quot;ID&quot;, &quot;Symbol&quot;, &quot;Type&quot;, as.character(sample_info$PatientID))] # # Run DESeq2 analysis # RunDESeq2(count_mat = mat, n.cont = 100, n.treat = 10, # prefix = &quot;../03.out/figure5/DESeq2_out_CEBPA_Mut_WT&quot;, # sort.p = FALSE, # merge.normalized = TRUE, # normalized_mat = tpm) library(patchwork) source(&quot;plotVolcanoV3.R&quot;) ##### TP53 de_results &lt;- read.table(&quot;../03.out/figure5/DESeq2_out_TP53_Mut_WT_with_normalized_mat.txt&quot;, header = TRUE) de_results_filtered &lt;- de_results[, 1:9] degs_tp53 &lt;- subset(de_results_filtered, abs(log2FoldChange) &gt; 0.25 &amp; padj &lt; 0.05) # Cap extreme values de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &lt; -5] &lt;- -5 de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &gt; 5] &lt;- 5 de_results_filtered$padj[de_results_filtered$padj &lt; 1e-6] &lt;- 1e-6 # Generate volcano plot volcano_plot1 &lt;- plotVolcano(mat = de_results_filtered, gene.col = &quot;Symbol&quot;, x.col = &quot;log2FoldChange&quot;, y.col = &quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1 = 0.05, y_cut2 = 0.01, x.lim = 5, y.lim = 6, label = FALSE, title = &quot;TP53 (Mut vs. WT)&quot;, selected_genes = &quot;NA&quot;) + theme_classic() ##### DNMT3A de_results &lt;- read.table(&quot;../03.out/figure5/DESeq2_out_DNMT3A_Mut_WT_with_normalized_mat.txt&quot;, header = TRUE) de_results_filtered &lt;- de_results[, 1:9] degs_dnmt3a &lt;- subset(de_results_filtered, abs(log2FoldChange) &gt; 0.25 &amp; padj &lt; 0.05) # Cap extreme values de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &lt; -4] &lt;- -4 de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &gt; 4] &lt;- 4 de_results_filtered$padj[de_results_filtered$padj &lt; 1e-6] &lt;- 1e-6 # Generate volcano plot volcano_plot2 &lt;- plotVolcano(mat = de_results_filtered, gene.col = &quot;Symbol&quot;, x.col = &quot;log2FoldChange&quot;, y.col = &quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1 = 0.05, y_cut2 = 0.01, x.lim = 4, y.lim = 6, label = FALSE, title = &quot;DNMT3A (Mut vs. WT)&quot;, selected_genes = &quot;NA&quot;) + theme_classic() ##### IDH2 de_results &lt;- read.table(&quot;../03.out/figure5/DESeq2_out_IDH2_Mut_WT_with_normalized_mat.txt&quot;, header = TRUE) de_results_filtered &lt;- de_results[, 1:9] degs_idh2 &lt;- subset(de_results_filtered, abs(log2FoldChange) &gt; 0.25 &amp; padj &lt; 0.05) # Cap extreme values de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &lt; -4] &lt;- -4 de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &gt; 4] &lt;- 4 de_results_filtered$padj[de_results_filtered$padj &lt; 1e-4] &lt;- 1e-4 # Generate volcano plot volcano_plot3 &lt;- plotVolcano(mat = de_results_filtered, gene.col = &quot;Symbol&quot;, x.col = &quot;log2FoldChange&quot;, y.col = &quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1 = 0.05, y_cut2 = 0.01, x.lim = 4, y.lim = 4, label = FALSE, title = &quot;IDH2 (Mut vs. WT)&quot;, selected_genes = &quot;NA&quot;) + theme_classic() ##### CEBPA de_results &lt;- read.table(&quot;../03.out/figure5/DESeq2_out_CEBPA_Mut_WT_with_normalized_mat.txt&quot;, header = TRUE) de_results_filtered &lt;- de_results[, 1:9] degs_cebpa &lt;- subset(de_results_filtered, abs(log2FoldChange) &gt; 0.25 &amp; padj &lt; 0.05) # Cap extreme values de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &lt; -5] &lt;- -5 de_results_filtered$log2FoldChange[de_results_filtered$log2FoldChange &gt; 5] &lt;- 5 de_results_filtered$padj[de_results_filtered$padj &lt; 1e-6] &lt;- 1e-6 # Generate volcano plot volcano_plot4 &lt;- plotVolcano(mat = de_results_filtered, gene.col = &quot;Symbol&quot;, x.col = &quot;log2FoldChange&quot;, y.col = &quot;padj&quot;, labx = &quot;log2FoldChange&quot;, laby = &quot;-Log10FDR&quot;, x_cut1 = 0.5, x_cut2 = 1, y_cut1 = 0.05, y_cut2 = 0.01, x.lim = 4, y.lim = 4, label = FALSE, title = &quot;CEBPA (Mut vs. WT)&quot;, selected_genes = &quot;NA&quot;) + theme_classic() plots &lt;- volcano_plot1|volcano_plot2|volcano_plot3|volcano_plot4 print(plots) # Save volcano plot # ggsave(plots, filename = &quot;../03.out/figure5/DESeq2_valcanoplot.pdf&quot;, width = 12, height = 3) "],["venn-diagram-for-target-genes.html", "6.11 Venn Diagram for target genes", " 6.11 Venn Diagram for target genes library(ggVennDiagram) stat1 &lt;- read.csv(&quot;../03.out/figure5/RF8_correlatedGenes.csv&quot;, header = T) stat1$rank_score &lt;- -log2(stat1$P.value) * abs(stat1$rho) stat1 &lt;- stat1[order(stat1$rank_score, decreasing = TRUE), ] rf8_genes &lt;- head(stat1, n=1000) # Example Venn plot for 5 sets venn_plot &lt;- ggVennDiagram( x = list( &quot;RF8-genes&quot; = rf8_genes$ID, &quot;TP53 mutation&quot; = degs_tp53$Symbol, &quot;DNMT3A mutation&quot; = degs_dnmt3a$Symbol, &quot;IDH2 mutation&quot; = degs_idh2$Symbol, &quot;CEBPA mutation&quot; = degs_cebpa$Symbol ), label_alpha = 0.5, edge_size = 0.5, label = &quot;count&quot; ) + ggtitle(&quot;Intersection of Gene Sets&quot;) + theme(legend.position = &quot;none&quot;) print(venn_plot) # Save each gene list to a CSV file write.csv(degs_tp53$Symbol, &quot;../03.out/figure5/TP53_genes.csv&quot;, row.names = FALSE) write.csv(degs_dnmt3a$Symbol, &quot;../03.out/figure5/DNMT3A_genes.csv&quot;, row.names = FALSE) write.csv(degs_idh2$Symbol, &quot;../03.out/figure5/IDH2_genes.csv&quot;, row.names = FALSE) write.csv(degs_cebpa$Symbol, &quot;../03.out/figure5/CEBPA_genes.csv&quot;, row.names = FALSE) "],["pathway-overlap-analysis-of-genes.html", "6.12 Pathway overlap analysis of genes", " 6.12 Pathway overlap analysis of genes library(clusterProfiler) library(org.Hs.eg.db) library(dplyr) library(ggpubr) library(patchwork) set.seed(123456) # Define your gene lists genes &lt;- list( RF8_gene = rf8_genes$ID, TP53_gene = degs_tp53$Symbol, DNMT3A_gene = degs_dnmt3a$Symbol, IDH2_gene = degs_idh2$Symbol, CEBPA_gene = degs_cebpa$Symbol ) # Map gene symbols to ENTREZ IDs genes &lt;- lapply(genes, function(gene_set) { mapIds( org.Hs.eg.db, keys = gene_set, column = &quot;ENTREZID&quot;, keytype = &quot;SYMBOL&quot;, multiVals = &quot;first&quot; ) %&gt;% na.omit() %&gt;% unique() }) # Obtain all gene-pathway associations from the database all_pathway_genes &lt;- AnnotationDbi::select( org.Hs.eg.db, keys = keys(org.Hs.eg.db, &quot;GO&quot;), columns = c(&quot;ENTREZID&quot;, &quot;GO&quot;, &quot;ONTOLOGY&quot;), keytype = &quot;GO&quot; ) %&gt;% filter(!is.na(GO)) # Calculate total gene counts per pathway and filter for at least 5 genes total_genes_per_pathway &lt;- all_pathway_genes %&gt;% group_by(GO) %&gt;% summarize(Total_Genes = n_distinct(ENTREZID)) %&gt;% filter(Total_Genes &gt;= 5) # Function to calculate overlap ratio for each gene list calculate_overlap_ratio &lt;- function(gene_list, pathway_genes, total_counts) { pathway_overlap &lt;- pathway_genes %&gt;% filter(ENTREZID %in% gene_list) %&gt;% group_by(GO, ONTOLOGY) %&gt;% summarize(Overlap_Count = n_distinct(ENTREZID), .groups = &quot;drop&quot;) %&gt;% left_join(total_counts, by = &quot;GO&quot;) %&gt;% mutate(Overlap_Ratio = Overlap_Count / Total_Genes) %&gt;% arrange(desc(Overlap_Ratio)) # Convert to data frame to avoid issues with tibble pathway_overlap &lt;- as.data.frame(pathway_overlap) return(pathway_overlap) } # Calculate overlap ratios for each gene list overlap_results &lt;- lapply(names(genes), function(list_name) { overlap_data &lt;- calculate_overlap_ratio(genes[[list_name]], all_pathway_genes, total_genes_per_pathway) # Safely select and rename columns overlap_data &lt;- overlap_data[, c(&quot;GO&quot;, &quot;Overlap_Ratio&quot;)] colnames(overlap_data)[2] &lt;- list_name # Dynamically assign the new column name return(overlap_data) }) # Combine results from all gene lists into a single data frame combined_overlap_results &lt;- Reduce(function(x, y) merge(x, y, by = &quot;GO&quot;, all = TRUE), overlap_results) # Save the results as a CSV file # write.csv(combined_overlap_results, &quot;../03.out/figure5/pathway_overlap_analysis_result.csv&quot;, row.names = FALSE) # Scatter plot function plot_scatter &lt;- function(data, x_col, y_col, color, x_label, y_label) { ggscatter( data = data, x = x_col, y = y_col, add = &quot;reg.line&quot;, # Add regression line conf.int = TRUE, # Add confidence interval add.params = list(color = &quot;black&quot;, fill = &quot;lightgray&quot;), # Regression line params color = color, # Scatter point color size = 2 # Point size ) + stat_cor(method = &quot;pearson&quot;) + labs(x = x_label, y = y_label) + # Axis labels theme_classic() + # Use a classic theme theme( strip.text = element_text(size = 12, face = &quot;bold&quot;), # Customize facet labels plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;),# Center-align title # plot.margin = margin(5, 5, 5, 5), # Reduce plot margins panel.spacing = unit(0.5, &quot;lines&quot;) # Reduce spacing between facets ) } # Scatter plots between different gene overlap ratios p1 &lt;- plot_scatter(combined_overlap_results, &quot;TP53_gene&quot;, &quot;RF8_gene&quot;, &quot;#1B9E77&quot;, &quot;% Pathway Overlap \\n(TP53 mutation-affected genes)&quot;, &quot;% Pathway Overlap (RF8-correlated genes)&quot;) p2 &lt;- plot_scatter(combined_overlap_results, &quot;DNMT3A_gene&quot;, &quot;RF8_gene&quot;, &quot;#D95F02&quot;, &quot;% Pathway Overlap \\n(DNMT3A mutation-affected genes)&quot;, &quot;% Pathway Overlap (RF8-correlated genes)&quot;) p3 &lt;- plot_scatter(combined_overlap_results, &quot;IDH2_gene&quot;, &quot;RF8_gene&quot;, &quot;#7570B3&quot;, &quot;% Pathway Overlap \\n(IDH2 mutation-affected genes)&quot;, &quot;% Pathway Overlap (RF8-correlated genes)&quot;) p4 &lt;- plot_scatter(combined_overlap_results, &quot;CEBPA_gene&quot;, &quot;RF8_gene&quot;, &quot;#E6AB02&quot;, &quot;% Pathway Overlap \\n(CEBPA mutation-affected genes)&quot;, &quot;% Pathway Overlap (RF8-correlated genes)&quot;) # Combine plots using patchwork plots &lt;- (p1 | p2) / (p3 | p4) print(plots) library(ggcorrplot) # Prepare the correlation matrix from the combined_overlap_results cor_matrix &lt;- cor(combined_overlap_results[,-1], use = &quot;pairwise.complete.obs&quot;) # Plot the correlation heatmap p &lt;- ggcorrplot( cor_matrix, method = &quot;circle&quot;, # Use circle style for visualization type = &quot;upper&quot;, # Show only the upper triangle lab = TRUE, # Add correlation coefficient labels lab_size = 4, # Label size colors = c(&quot;#6D9EC1&quot;, &quot;white&quot;, &quot;#E46726&quot;), # Color gradient (blue-white-red) title = &quot;Correlation of Pathway Overlap Ratios&quot;, outline.color = &quot;black&quot; # Outline color for circles ) print(p) "],["figure-6.html", "Chapter 7 Figure 6", " Chapter 7 Figure 6 Monotonic relationship between RF8 scores, response probability, and survival following venetoclax-azacitidine therapy "],["relationship-between-rf8-score-vs.-venaza-response-probability.html", "7.1 Relationship between RF8 score vs. VEN/AZA response probability", " 7.1 Relationship between RF8 score vs. VEN/AZA response probability # import sys # import time # import pandas as pd # import numpy as np # import matplotlib.pyplot as plt # import random # import seaborn as sns # # import sklearn.neighbors._base # sys.modules[&#39;sklearn.neighbors.base&#39;] = sklearn.neighbors._base # # plt.rcParams.update({&#39;font.size&#39;: 9}) # plt.rcParams[&quot;font.family&quot;] = &quot;Arial&quot; # palette = sns.color_palette(&quot;deep&quot;) # # # if __name__ == &quot;__main__&quot;: # # bs_number = 1000 # bootstrapping # random.seed(1) # # bin_size = 0.1 # # start_time = time.time() # print(&#39;Raw data read in ...&#39;) # # # Read RF8 prediction data # fnIn = &#39;../03.out/figure6/01.RF8_SurvivalAnalysis.xlsx&#39; # y_pred_RF8 = [] # y_true = [] # output_curve_fn = &#39;RF8_vs_ORR&#39; + &#39;.png&#39; # # # Reading only one sheet, since you have only one sheet in the file # data = pd.read_excel(fnIn, sheet_name=0, header=0, index_col=0) # # # Extract relevant columns for prediction and true response # y_pred_RF8 = data[&#39;RF8.prob.CR&#39;].tolist() # RF8 predicted response probability # y_true = data[&#39;Response&#39;].tolist() # True response (0 or 1) # # y_true = np.array(y_true) # y_pred_RF8 = np.array(y_pred_RF8) # score_list_RF8 = np.arange(0.0, 1.01, 0.01) # RF8_num = len(score_list_RF8) # # RF8high_ORR_list = [[] for _ in range(RF8_num)] # RF8low_ORR_list = [[] for _ in range(RF8_num)] # RF8_ORR_list = [[] for _ in range(RF8_num)] # RF8_patientNUM_list = [[] for _ in range(RF8_num)] # sampleNUM = len(y_true) # idx_list = range(sampleNUM) # print(&#39;Sample num:&#39;, sampleNUM) # # # Bootstrap resampling and ORR calculation # for bs in range(bs_number): # idx_resampled = random.choices(idx_list, k=sampleNUM) # y_true_resampled = y_true[idx_resampled] # y_pred_RF8_resampled = y_pred_RF8[idx_resampled] # # for score_i in range(len(score_list_RF8)): # score = score_list_RF8[score_i] # idx_high_interval = y_pred_RF8_resampled &gt;= score # y_true_high = y_true_resampled[idx_high_interval] # Rhigh_num = sum(y_true_high) # tot_high_num = len(y_true_high) # patientRatio_temp = sum(y_pred_RF8_resampled &lt; score) / sampleNUM # RF8_patientNUM_list[score_i].append(patientRatio_temp) # # if not tot_high_num: # RF8high_ORR_list[score_i].append(RF8high_ORR_list[score_i-1][-1]) # else: # ORRhigh_temp = Rhigh_num / tot_high_num # RF8high_ORR_list[score_i].append(ORRhigh_temp) # # idx_low_interval = y_pred_RF8_resampled &lt; score # y_true_low = y_true_resampled[idx_low_interval] # Rlow_num = sum(y_true_low) # tot_low_num = len(y_true_low) # # if not tot_low_num: # RF8low_ORR_list[score_i].append(0) # else: # ORRlow_temp = Rlow_num / tot_low_num # RF8low_ORR_list[score_i].append(ORRlow_temp) # # if sum(y_pred_RF8_resampled &lt;= score + bin_size / 2) &lt; 0.01 * len(y_pred_RF8_resampled): # idx_interval = [] # elif sum(y_pred_RF8_resampled &gt; score - bin_size / 2) &lt; 0.01 * len(y_pred_RF8_resampled): # idx_interval = (y_pred_RF8_resampled &gt; score - bin_size / 2) # else: # idx_interval = (y_pred_RF8_resampled &lt;= score + bin_size / 2) &amp; (y_pred_RF8_resampled &gt; score - bin_size / 2) # # y_true_temp = y_true_resampled[idx_interval] # R_num = sum(y_true_temp) # tot_num = len(y_true_temp) # # if not tot_num: # RF8_ORR_list[score_i].append(0) # else: # ORR_temp = R_num / tot_num # RF8_ORR_list[score_i].append(ORR_temp) # # if sum(y_pred_RF8_resampled &gt; score - bin_size / 2) &lt; 0.01 * len(y_pred_RF8_resampled): # break # # # Remove empty elements for high scores # for i in range(len(RF8high_ORR_list)): # if len(RF8high_ORR_list[i]) == 0: # break # RF8high_ORR_list = RF8high_ORR_list[0:i] # RF8low_ORR_list = RF8low_ORR_list[0:i] # RF8_ORR_list = RF8_ORR_list[0:i] # RF8_patientNUM_list = RF8_patientNUM_list[0:i] # score_list_RF8 = score_list_RF8[0:i] # # # Compute mean and confidence intervals # RF8high_ORR_mean = [np.mean(c) for c in RF8high_ORR_list] # RF8high_ORR_05 = [np.quantile(c, 0.05) for c in RF8high_ORR_list] # RF8high_ORR_95 = [np.quantile(c, 0.95) for c in RF8high_ORR_list] # RF8low_ORR_mean = [np.mean(c) for c in RF8low_ORR_list] # RF8low_ORR_05 = [np.quantile(c, 0.05) for c in RF8low_ORR_list] # RF8low_ORR_95 = [np.quantile(c, 0.95) for c in RF8low_ORR_list] # RF8low_patientRatio_mean = [np.mean(c) for c in RF8_patientNUM_list] # RF8_ORR_mean = [np.mean(c) for c in RF8_ORR_list] # RF8_ORR_05 = [np.quantile(c, 0.05) for c in RF8_ORR_list] # RF8_ORR_95 = [np.quantile(c, 0.95) for c in RF8_ORR_list] # RF8_patientRatio_mean = [np.mean(c) for c in RF8_patientNUM_list] # # print(&#39;RF8 response odds:&#39;) # for i in range(len(RF8high_ORR_95)): # print(score_list_RF8[i], RF8high_ORR_mean[i], RF8low_ORR_mean[i], RF8_ORR_mean[i], RF8low_patientRatio_mean[i]) # # # Save results to CSV files # df = pd.DataFrame({&#39;RF8_score&#39;: score_list_RF8, &#39;Prob_mean&#39;: RF8_ORR_mean, &#39;Prob_lower&#39;: RF8_ORR_05, &#39;Prob_upper&#39;: RF8_ORR_95}) # df.to_csv(&#39;../03.out/figure6/source_data_forplot.csv&#39;, index=False) # # # Plotting Score-Prob curve # fig1, axes = plt.subplots(1, 1, figsize=(6.5, 2.8)) # fig1.subplots_adjust(left=0.1, bottom=0.15, right=0.98, top=0.96) # axes.plot(score_list_RF8, RF8_ORR_mean, &#39;-&#39;, color=&#39;r&#39;) # axes.fill_between(score_list_RF8, RF8_ORR_05, RF8_ORR_95, facecolor=&#39;r&#39;, alpha=0.25) # axes.set_ylabel(&quot;Response probability (%)&quot;, color=&quot;k&quot;) # axes.set_xlabel(&#39;RF8&#39;) # RF8 score # # axes.set_ylim([-0.02, 1.02]) # axes.set_yticks([0, 0.25, 0.5, 0.75, 1]) # axes.set_yticklabels([0, 25, 50, 75, 100]) # axes.spines[&#39;right&#39;].set_visible(False) "],["monotonic-response-prediction-plot.html", "7.2 Monotonic Response Prediction Plot", " 7.2 Monotonic Response Prediction Plot library(ggplot2) library(scales) # Load data for plotting df &lt;- read.csv(&quot;../03.out/figure6/source_data_forplot.csv&quot;, header = TRUE) # Create the plot p1 &lt;- ggplot(df, aes(x = RF8_score, y = Prob_mean * 100)) + geom_line(color = &quot;red&quot;) + geom_ribbon(aes(ymin = Prob_lower * 100, ymax = Prob_upper * 100), fill = &quot;red&quot;, alpha = 0.2) + labs(x = &quot;RF8 Score&quot;, y = &quot;Response Probability (%)&quot;) + theme_classic() + scale_y_continuous(breaks = seq(0, 100, by = 10)) + scale_x_continuous(breaks = seq(0, 1, by = 0.1)) + theme( panel.grid.major = element_line(size = 0.25, linetype = &quot;dashed&quot;, colour = &quot;grey&quot;), panel.grid.minor = element_line(size = 0.25, linetype = &quot;dashed&quot;, colour = &quot;grey&quot;), panel.grid.major.x = element_blank() ) print(p1) "],["survival-plot.html", "7.3 Survival plot", " 7.3 Survival plot library(survival) library(survminer) library(readxl) # Load survival analysis data data &lt;- read_xlsx(&quot;../03.out/figure6/01.RF8_SurvivalAnalysis.xlsx&quot;) data$RF8.group &lt;- factor(data$RF8.group, levels = c(&quot;High&quot;, &quot;Intermediate&quot;, &quot;Low&quot;)) # Count samples in each group n_high &lt;- sum(data$RF8.group == &quot;High&quot;) n_intermediate &lt;- sum(data$RF8.group == &quot;Intermediate&quot;) n_low &lt;- sum(data$RF8.group == &quot;Low&quot;) # Fit the survival model (Event-Free Survival) fit_efs &lt;- survfit(Surv(EFS_Time, EFS_Status) ~ RF8.group, data = data) # Perform Cox proportional hazards model for pairwise comparisons cox_model_efs &lt;- coxph(Surv(EFS_Time, EFS_Status) ~ RF8.group, data = data) summary_cox_efs &lt;- summary(cox_model_efs) hr_values_efs &lt;- exp(summary_cox_efs$coefficients[, &quot;coef&quot;]) # Hazard ratios p_values_efs &lt;- summary_cox_efs$coefficients[, &quot;Pr(&gt;|z|)&quot;] # P-values # Extract HR and p-values for group comparisons hr_high_intermediate_efs &lt;- hr_values_efs[&quot;RF8.groupIntermediate&quot;] pval_high_intermediate_efs &lt;- p_values_efs[&quot;RF8.groupIntermediate&quot;] hr_high_low_efs &lt;- hr_values_efs[&quot;RF8.groupLow&quot;] pval_high_low_efs &lt;- p_values_efs[&quot;RF8.groupLow&quot;] # Create labels for hazard ratios and p-values label_high_intermediate_efs &lt;- paste0(&quot;HR (Intermediate vs High): &quot;, round(hr_high_intermediate_efs, 2), &quot;, P = &quot;, format.pval(pval_high_intermediate_efs, digits = 3)) label_high_low_efs &lt;- paste0(&quot;HR (Low vs High): &quot;, round(hr_high_low_efs, 2), &quot;, P = &quot;, format.pval(pval_high_low_efs, digits = 3)) # Create legend labels with sample counts legend_labels_efs &lt;- c( paste0(&quot;High (n = &quot;, n_high, &quot;)&quot;), paste0(&quot;Intermediate (n = &quot;, n_intermediate, &quot;)&quot;), paste0(&quot;Low (n = &quot;, n_low, &quot;)&quot;) ) # Plot Kaplan-Meier curves for Event-Free Survival p2 &lt;- ggsurvplot(fit_efs, data = data, pval = TRUE, conf.int = FALSE, palette = c(&quot;#7c9d97&quot;, &quot;#9cb0c3&quot;, &quot;#e9b383&quot;), risk.table = FALSE, font.legend = 13, legend.title = &quot;RF8&quot;, legend = c(0.75, 0.85), xlab = &#39;Survival Time (years)&#39;, ylab = &#39;Survival Probability (EFS)&#39;, legend.labs = legend_labels_efs) # Annotate the plot with HR and p-values p2$plot &lt;- p2$plot + annotate(&quot;text&quot;, x = max(data$OS_Time) * 0.8, y = 0.4, label = label_high_intermediate_efs, size = 4, hjust = 0) + annotate(&quot;text&quot;, x = max(data$OS_Time) * 0.8, y = 0.3, label = label_high_low_efs, size = 4, hjust = 0) print(p2) #################################### # Overall Survival Prediction (OS) #################################### # Fit the survival model (Overall Survival) fit_os &lt;- survfit(Surv(OS_Time, OS_Status) ~ RF8.group, data = data) # Perform Cox proportional hazards model for pairwise comparisons cox_model_os &lt;- coxph(Surv(OS_Time, OS_Status) ~ RF8.group, data = data) summary_cox_os &lt;- summary(cox_model_os) hr_values_os &lt;- exp(summary_cox_os$coefficients[, &quot;coef&quot;]) p_values_os &lt;- summary_cox_os$coefficients[, &quot;Pr(&gt;|z|)&quot;] # Extract HR and p-values for group comparisons hr_high_intermediate_os &lt;- hr_values_os[&quot;RF8.groupIntermediate&quot;] pval_high_intermediate_os &lt;- p_values_os[&quot;RF8.groupIntermediate&quot;] hr_high_low_os &lt;- hr_values_os[&quot;RF8.groupLow&quot;] pval_high_low_os &lt;- p_values_os[&quot;RF8.groupLow&quot;] # Create labels for hazard ratios and p-values label_high_intermediate_os &lt;- paste0(&quot;HR (Intermediate vs High): &quot;, round(hr_high_intermediate_os, 2), &quot;, P = &quot;, format.pval(pval_high_intermediate_os, digits = 3)) label_high_low_os &lt;- paste0(&quot;HR (Low vs High): &quot;, round(hr_high_low_os, 2), &quot;, P = &quot;, format.pval(pval_high_low_os, digits = 3)) # Plot Kaplan-Meier curves for Overall Survival p3 &lt;- ggsurvplot(fit_os, data = data, pval = TRUE, conf.int = FALSE, palette = c(&quot;#7c9d97&quot;, &quot;#9cb0c3&quot;, &quot;#e9b383&quot;), risk.table = FALSE, font.legend = 13, legend.title = &quot;RF8&quot;, legend = c(0.75, 0.85), xlab = &#39;Survival Time (years)&#39;, ylab = &#39;Survival Probability (OS)&#39;, legend.labs = legend_labels_efs) # Annotate the plot with HR and p-values p3$plot &lt;- p3$plot + annotate(&quot;text&quot;, x = max(data$OS_Time) * 0.8, y = 0.4, label = label_high_intermediate_os, size = 4, hjust = 0) + annotate(&quot;text&quot;, x = max(data$OS_Time) * 0.8, y = 0.3, label = label_high_low_os, size = 4, hjust = 0) print(p3) "],["brier-score-analysis.html", "7.4 Brier Score Analysis", " 7.4 Brier Score Analysis library(pec) library(survival) library(readxl) # Load data data &lt;- read_xlsx(&quot;../03.out/figure6/01.RF8_SurvivalAnalysis.xlsx&quot;) # Define models for Event-Free Survival (EFS) models_efs &lt;- list( &quot;RF8&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ RF8.prob.CR, data = data, x = TRUE, y = TRUE), &quot;ELN2022&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ ELN2022, data = data, x = TRUE, y = TRUE), &quot;ELN2024&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ ELN2024, data = data, x = TRUE, y = TRUE), &quot;gene4_signature&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ gene4_signature, data = data, x = TRUE, y = TRUE), &quot;molecular_predictor&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ molecular_predictor, data = data, x = TRUE, y = TRUE), &quot;mayo_predictor&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ mayo_predictor, data = data, x = TRUE, y = TRUE) ) # Calculate Brier scores for EFS brier_efs &lt;- pec(models_efs, data = data, formula = Surv(EFS_Time, EFS_Status) ~ 1) print(brier_efs) ## ## Prediction error curves ## ## Prediction models: ## ## Reference RF8 ELN2022 ELN2024 ## Reference RF8 ELN2022 ELN2024 ## gene4_signature molecular_predictor mayo_predictor ## gene4_signature molecular_predictor mayo_predictor ## ## Right-censored response of a survival model ## ## No.Observations: 110 ## ## Pattern: ## Freq ## event 60 ## right.censored 50 ## ## IPCW: marginal model ## ## No data splitting: either apparent or independent test sample performance ## ## Cumulative prediction error, aka Integrated Brier score (IBS) ## aka Cumulative rank probability score ## ## Range of integration: 0 and time=3.6 : ## ## ## Integrated Brier score (crps): ## ## IBS[0;time=3.6) ## Reference 0.224 ## RF8 0.169 ## ELN2022 0.225 ## ELN2024 0.206 ## gene4_signature 0.206 ## molecular_predictor 0.206 ## mayo_predictor 0.210 # Plot Brier scores for EFS # pdf(&quot;../03.out/figure6/01.BrierScores_EFS.pdf&quot;, width = 4, height = 4.3) out &lt;- plot( brier_efs, xlim = c(0, 3), col = c(&quot;black&quot;, &quot;#E74342&quot;, &quot;#3469AF&quot;, &quot;#38AC6B&quot;, &quot;#9A78B4&quot;, &quot;#73C8EF&quot;,&quot;#E5C494&quot;), lwd = 2.5, xlab = &quot;Survival Time (years)&quot;, ylab = &quot;Prediction Error (Brier Score)&quot;, main = &quot;Brier Score for Event-Free Survival (EFS)&quot;, legend = TRUE ) grid(col = &quot;gray&quot;, lty = &quot;dotted&quot;, lwd = 0.8) # dev.off() print(out) ## ## Prediction error curves ## ## Prediction models: ## ## Reference RF8 ELN2022 ELN2024 ## Reference RF8 ELN2022 ELN2024 ## gene4_signature molecular_predictor mayo_predictor ## gene4_signature molecular_predictor mayo_predictor ## ## Right-censored response of a survival model ## ## No.Observations: 110 ## ## Pattern: ## Freq ## event 60 ## right.censored 50 ## ## IPCW: marginal model ## ## No data splitting: either apparent or independent test sample performance ## ## Cumulative prediction error, aka Integrated Brier score (IBS) ## aka Cumulative rank probability score ## ## Range of integration: 0 and time=3.6 : ## ## ## Integrated Brier score (crps): ## ## IBS[0;time=3.6) ## Reference 0.224 ## RF8 0.169 ## ELN2022 0.225 ## ELN2024 0.206 ## gene4_signature 0.206 ## molecular_predictor 0.206 ## mayo_predictor 0.210 # Define models for Overall Survival (OS) models_os &lt;- list( &quot;RF8&quot; = coxph(Surv(OS_Time, OS_Status) ~ RF8.prob.CR, data = data, x = TRUE, y = TRUE), &quot;ELN2022&quot; = coxph(Surv(OS_Time, OS_Status) ~ ELN2022, data = data, x = TRUE, y = TRUE), &quot;ELN2024&quot; = coxph(Surv(EFS_Time, EFS_Status) ~ ELN2024, data = data, x = TRUE, y = TRUE), &quot;gene4_signature&quot; = coxph(Surv(OS_Time, OS_Status) ~ gene4_signature, data = data, x = TRUE, y = TRUE), &quot;molecular_predictor&quot; = coxph(Surv(OS_Time, OS_Status) ~ molecular_predictor, data = data, x = TRUE, y = TRUE), &quot;mayo_predictor&quot; = coxph(Surv(OS_Time, OS_Status) ~ mayo_predictor, data = data, x = TRUE, y = TRUE) ) # Calculate Brier scores for OS brier_os &lt;- pec(models_os, data = data, formula = Surv(OS_Time, OS_Status) ~ 1) print(brier_os) ## ## Prediction error curves ## ## Prediction models: ## ## Reference RF8 ELN2022 ELN2024 ## Reference RF8 ELN2022 ELN2024 ## gene4_signature molecular_predictor mayo_predictor ## gene4_signature molecular_predictor mayo_predictor ## ## Right-censored response of a survival model ## ## No.Observations: 110 ## ## Pattern: ## Freq ## event 51 ## right.censored 59 ## ## IPCW: marginal model ## ## No data splitting: either apparent or independent test sample performance ## ## Cumulative prediction error, aka Integrated Brier score (IBS) ## aka Cumulative rank probability score ## ## Range of integration: 0 and time=3.6 : ## ## ## Integrated Brier score (crps): ## ## IBS[0;time=3.6) ## Reference 0.210 ## RF8 0.161 ## ELN2022 0.213 ## ELN2024 0.202 ## gene4_signature 0.191 ## molecular_predictor 0.190 ## mayo_predictor 0.194 # Plot Brier scores for OS # pdf(&quot;../03.out/figure6/01.BrierScores_OS.pdf&quot;, width = 4, height = 4.3) out &lt;- plot( brier_os, xlim = c(0, 3), col = c(&quot;black&quot;, &quot;#E74342&quot;, &quot;#3469AF&quot;, &quot;#38AC6B&quot;, &quot;#9A78B4&quot;, &quot;#73C8EF&quot;,&quot;#E5C494&quot;), lwd = 2.5, xlab = &quot;Survival Time (years)&quot;, ylab = &quot;Prediction Error (Brier Score)&quot;, main = &quot;Brier Score for Overall Survival (OS)&quot;, legend = TRUE ) grid(col = &quot;gray&quot;, lty = &quot;dotted&quot;, lwd = 0.8) # dev.off() print(out) ## ## Prediction error curves ## ## Prediction models: ## ## Reference RF8 ELN2022 ELN2024 ## Reference RF8 ELN2022 ELN2024 ## gene4_signature molecular_predictor mayo_predictor ## gene4_signature molecular_predictor mayo_predictor ## ## Right-censored response of a survival model ## ## No.Observations: 110 ## ## Pattern: ## Freq ## event 51 ## right.censored 59 ## ## IPCW: marginal model ## ## No data splitting: either apparent or independent test sample performance ## ## Cumulative prediction error, aka Integrated Brier score (IBS) ## aka Cumulative rank probability score ## ## Range of integration: 0 and time=3.6 : ## ## ## Integrated Brier score (crps): ## ## IBS[0;time=3.6) ## Reference 0.210 ## RF8 0.161 ## ELN2022 0.213 ## ELN2024 0.202 ## gene4_signature 0.191 ## molecular_predictor 0.190 ## mayo_predictor 0.194 "],["c-index-comparison.html", "7.5 C-index Comparison", " 7.5 C-index Comparison library(survcomp) library(survival) library(readxl) library(ggplot2) # Load data data &lt;- read_xlsx(&quot;../03.out/figure6/01.RF8_SurvivalAnalysis.xlsx&quot;) features &lt;- c(&quot;RF8.prob.CR&quot;, &quot;ELN2022&quot;, &quot;ELN2024&quot;, &quot;gene4_signature&quot;, &quot;molecular_predictor&quot;, &quot;mayo_predictor&quot;) # Initialize an empty data frame to store C-index results c_index_df &lt;- data.frame( Feature = character(), Outcome = character(), C_index = numeric(), Lower_CI = numeric(), Upper_CI = numeric(), stringsAsFactors = FALSE ) # Loop through each feature to calculate C-index and 95% CI for both OS and EFS for (feature in features) { # Calculate C-index for OS cox_model_os &lt;- coxph(Surv(OS_Time, OS_Status) ~ data[[feature]], data = data) predictions_os &lt;- predict(cox_model_os) c_index_result_os &lt;- concordance.index(predictions_os, surv.time = data$OS_Time, surv.event = data$OS_Status) # Store OS results in the dataframe c_index_df &lt;- rbind(c_index_df, data.frame( Feature = feature, Outcome = &quot;OS&quot;, C_index = round(c_index_result_os$c.index, 3), Lower_CI = round(c_index_result_os$lower, 3), Upper_CI = round(c_index_result_os$upper, 3) )) # Calculate C-index for EFS cox_model_efs &lt;- coxph(Surv(EFS_Time, EFS_Status) ~ data[[feature]], data = data) predictions_efs &lt;- predict(cox_model_efs) c_index_result_efs &lt;- concordance.index(predictions_efs, surv.time = data$EFS_Time, surv.event = data$EFS_Status) # Store EFS results in the dataframe c_index_df &lt;- rbind(c_index_df, data.frame( Feature = feature, Outcome = &quot;EFS&quot;, C_index = round(c_index_result_efs$c.index, 3), Lower_CI = round(c_index_result_efs$lower, 3), Upper_CI = round(c_index_result_efs$upper, 3) )) } # Display the C-index dataframe c_index_df ## Feature Outcome C_index Lower_CI Upper_CI ## 1 RF8.prob.CR OS 0.732 0.564 0.853 ## 2 RF8.prob.CR EFS 0.723 0.569 0.838 ## 3 ELN2022 OS 0.575 0.373 0.755 ## 4 ELN2022 EFS 0.544 0.361 0.716 ## 5 ELN2024 OS 0.654 0.435 0.823 ## 6 ELN2024 EFS 0.633 0.429 0.798 ## 7 gene4_signature OS 0.646 0.422 0.820 ## 8 gene4_signature EFS 0.640 0.432 0.806 ## 9 molecular_predictor OS 0.623 0.421 0.789 ## 10 molecular_predictor EFS 0.651 0.464 0.800 ## 11 mayo_predictor OS 0.657 0.452 0.817 ## 12 mayo_predictor EFS 0.680 0.491 0.824 # Set factor levels for Feature to maintain consistent ordering in the plot c_index_df$Feature &lt;- factor(c_index_df$Feature, levels = features) # Plot C-index results p4 &lt;- ggplot(c_index_df, aes(x = Feature, y = C_index, fill = Feature)) + geom_errorbar(aes(ymin = Lower_CI, ymax = Upper_CI), width = 0.2, size = 0.8) + geom_bar(stat = &quot;identity&quot;, width = 1) + facet_wrap(~ Outcome) + labs(y = &quot;C-index&quot;, x = &quot;&quot;, title = &quot;C-index with 95% CI for OS and EFS&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_fill_brewer(palette = &quot;Set1&quot;) print(p4) # Save the C-index plot # ggsave(p4, filename = &quot;../03.out/figure6/03.cindex.pdf&quot;, width = 7.4, height = 5) "],["km-plots-for-rjaml-cohort-2.html", "7.6 KM-Plots for RJAML Cohort 2", " 7.6 KM-Plots for RJAML Cohort 2 library(ggplot2) library(survminer) library(survival) # Load survival data for Cohort 2 data &lt;- read.csv(&quot;../03.out/figure6/RF8_Cohort2_survival.csv&quot;, header = TRUE) # Create predicted groups based on RF8 probability tertiles data$Predicted_group &lt;- cut(data$RF8.prob.CR, breaks = quantile(data$RF8.prob.CR, probs = c(0, 0.34, 0.68, 1)), labels = c(&quot;0-34%&quot;, &quot;34-68%&quot;, &quot;68-100%&quot;), include.lowest = TRUE) # Get group counts for legend labels group_counts &lt;- table(data$Predicted_group) # Create labels for the legend with group sizes legend_labs &lt;- c(paste0(&quot;0-34% (N = &quot;, group_counts[&quot;0-34%&quot;], &quot;)&quot;), paste0(&quot;34-68% (N = &quot;, group_counts[&quot;34-68%&quot;], &quot;)&quot;), paste0(&quot;68-100% (N = &quot;, group_counts[&quot;68-100%&quot;], &quot;)&quot;)) # EFS - Calculate C-index and HR fit_efs &lt;- survfit(Surv(EFS_Time, EFS_Status) ~ Predicted_group, data = data) cox_model_efs &lt;- coxph(Surv(EFS_Time, EFS_Status) ~ Predicted_group, data = data) c_index_efs &lt;- summary(cox_model_efs)$concordance[1] hr_efs &lt;- exp(coef(cox_model_efs))[1] hr_ci_efs &lt;- exp(confint(cox_model_efs))[1,] hr_label_efs &lt;- paste0(&quot;HR: &quot;, round(hr_efs, 2), &quot; (95% CI: &quot;, round(hr_ci_efs[1], 2), &quot; - &quot;, round(hr_ci_efs[2], 2), &quot;)&quot;) c_index_label_efs &lt;- paste0(&quot;C-index: &quot;, round(c_index_efs, 3)) # EFS Plot p5 &lt;- ggsurvplot(fit_efs, data = data, pval = TRUE, conf.int = FALSE, risk.table = FALSE, font.legend = 13, legend.title = &quot;RF8 score tertiles&quot;, legend = c(0.75, 0.35), xlab = &#39;Survival time (days)&#39;, ylab = &#39;Survival probability (EFS)&#39;, legend.labs = legend_labs, palette = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;)) + labs(caption = paste0(c_index_label_efs, &quot;\\n&quot;, hr_label_efs)) print(p5) # OS - Calculate C-index and HR fit_os &lt;- survfit(Surv(OS_Time, OS_Status) ~ Predicted_group, data = data) cox_model_os &lt;- coxph(Surv(OS_Time, OS_Status) ~ Predicted_group, data = data) c_index_os &lt;- summary(cox_model_os)$concordance[1] hr_os &lt;- exp(coef(cox_model_os))[1] hr_ci_os &lt;- exp(confint(cox_model_os))[1,] hr_label_os &lt;- paste0(&quot;HR: &quot;, round(hr_os, 2), &quot; (95% CI: &quot;, round(hr_ci_os[1], 2), &quot; - &quot;, round(hr_ci_os[2], 2), &quot;)&quot;) c_index_label_os &lt;- paste0(&quot;C-index: &quot;, round(c_index_os, 3)) # OS Plot p6 &lt;- ggsurvplot(fit_os, data = data, pval = TRUE, conf.int = FALSE, risk.table = FALSE, font.legend = 13, legend.title = &quot;RF8 score tertiles&quot;, legend = c(0.75, 0.35), xlab = &#39;Survival time (days)&#39;, ylab = &#39;Survival probability (OS)&#39;, legend.labs = legend_labs) + labs(caption = paste0(c_index_label_os, &quot;\\n&quot;, hr_label_os)) print(p6) "],["barplot-for-crcri.html", "7.7 Barplot for CR/CRi", " 7.7 Barplot for CR/CRi library(ggplot2) library(readxl) library(patchwork) # Load response data for Cohort 2 data &lt;- read.csv(&quot;../03.out/figure6/RF8_Cohort2_survival.csv&quot;, header = TRUE) # Create predicted groups based on RF8 probability tertiles data$Predicted_group &lt;- cut(data$RF8.prob.CR, breaks = quantile(data$RF8.prob.CR, probs = c(0, 0.34, 0.68, 1)), labels = c(&quot;0-34%&quot;, &quot;34-68%&quot;, &quot;68-100%&quot;), include.lowest = TRUE) # Summarize CR/CRi rates by predicted group response_summary &lt;- aggregate(Response ~ Predicted_group, data, function(x) { mean(x == &quot;CR&quot;) * 100 }) colnames(response_summary)[2] &lt;- &quot;CR_Percentage&quot; # Create the barplot p7 &lt;- ggplot(response_summary, aes(x = Predicted_group, y = CR_Percentage, fill = Predicted_group)) + geom_bar(stat = &quot;identity&quot;, width = 0.6) + geom_text(aes(label = paste0(round(CR_Percentage, 1), &quot;%&quot;)), vjust = -0.5) + labs(x = &quot;Groups stratified by RF8 scores&quot;, y = &quot;CR/CRi (%)&quot;) + ylim(0, 100) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 0, hjust = 1)) print(p7) # Save the barplot # ggsave(p7, filename = &quot;../03.out/figure6/04.barplot_CR_rate_tertiles.pdf&quot;, width = 5, height = 4) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
